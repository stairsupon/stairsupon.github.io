{"meta":{"title":"Stairs_upon_temple","subtitle":"","description":"","author":"Stairs_upon_temple","url":"http://stairsupon.github.io","root":"/"},"pages":[{"title":"","date":"2025-01-21T01:36:46.026Z","updated":"2025-01-21T01:36:46.026Z","comments":true,"path":"404/index.html","permalink":"http://stairsupon.github.io/404/index.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2025-01-21T07:11:37.485Z","updated":"2025-01-21T01:40:21.994Z","comments":true,"path":"about/index.html","permalink":"http://stairsupon.github.io/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"我的朋友们","date":"2025-01-21T01:35:54.497Z","updated":"2025-01-21T01:35:54.497Z","comments":true,"path":"friends/index.html","permalink":"http://stairsupon.github.io/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有分类","date":"2025-01-21T01:35:33.657Z","updated":"2025-01-21T01:35:33.657Z","comments":true,"path":"categories/index.html","permalink":"http://stairsupon.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2025-01-21T01:35:21.232Z","updated":"2025-01-21T01:35:21.232Z","comments":true,"path":"tags/index.html","permalink":"http://stairsupon.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"NOIp 2024 游记 & 退役感言","slug":"wordstoOIerslater","date":"2024-12-14T06:38:00.000Z","updated":"2025-01-21T07:28:18.738Z","comments":true,"path":"2024/12/14/wordstoOIerslater/","permalink":"http://stairsupon.github.io/2024/12/14/wordstoOIerslater/","excerpt":"","text":"结束了，一切都结束了。 先浅谈一下这次 NOIP 首先本来这次是抱着很大的希望的，毕竟准备了那么久，还是希望能够拿到比较高的奖项，然而结果却非常令人失望。 DAY 0 考前为了鼓舞士气，我特意做了个主题，现在看来却是讽刺至极。 因为考试当天是星期六，所以在此之前一天我们收拾收拾就回去了，刚好还能不占月假（因为学竞赛，这可能是我们第一次放月假），回到家后想起同学说的长 RP 的好方法 —— 把线段树的模板打一遍，不编译直接提交看能不能一遍过，当时我觉得线段树太简单，决定在此基础上加点难度，于是我直接打树剖模板题，结果当时我想着线段树空间开四倍，一不小心写成了右移四，导致 MLE , 然后改了之后就洗洗睡了，顺带上号把每日任务做了一些（还刷出一个高资）。 DAY 1 考试当天，七点钟已经到达考试地点也就是七中高新，在门口简单吃了一顿早饭，便开始用手机复习一些模板，顺带提交了早就写好的 P4994 终于结束的起点的代码，然后准备入场。 试机 他甚至还有试机时间，这应该是我第一次试机，利用这个时间，我打了一边超级快读和线段树，已备不时之需，此刻我的心里一直鼓励自己，加油。 考试 试题也是发的比较快，还没到点就发下来了，我以自己最快的速度打开试卷，开始读题，当时第一题刚读完，就已经有思路了，简单在草稿纸上推了一下，马上就开始写，也是用了不到 5 min 就写完了，测了一下样例，小样例随便过，而再测大样例的时候就没那么幸运了，结果大了很多，当时我以为是写挂了，于是调了半天（ about 1 hour ），也没调出来当时想着放一放去做下一题。 第二题看上去就很和善，看完之后想到要推式子，但对个人实力不太认可，于是决定骗分（赛后觉得糖丸了，当时还剩三个小时，绝对推得出来），骗分的过程也是相当愉快，很快就骗到 60 分了，大概花了半个小时。 此时，我还剩 2.5 hour 我能干的要么去看后面的题，要么把 T1 切了。一向不擅长选择的我选择了前者（事实证明，如果当时我两个都不选，而是把题全部再读一遍，可能会好很多）。回过头来调 T1 的过程相当痛苦，反复造样例反复算，就是 hack 不了。无奈之下看了一眼 T3 , 结果发现看不了一点，晃了一眼 T4 似乎有点树剖的想法，但想了一想（当时还剩 30 min），还是做 T1 收益最大，当时我已心灰意冷，不知所措，回想自己两年以来的 OI 生涯，感觉懊恼不已。在此刻我选择把题再读一遍，结果却是令人绝望的，我居然把 T1 题面读错了，没有看到相邻两个字，我感觉我已经处于崩溃的边缘，甚至当时不知怎么，我居然笑了出来（现在想起这是多么令人绝望的笑）。 在如此绝望的情形下，我想平时切黄体差不多 10 min ，这题估计也就是个黄题（赛后想了想，抛开证明难度差不多是黄题），然后在心中为自己加油打气，用了 10 min 想外加 10 min 重构（当时全程手都在抖，考完后键盘上全是汗），代码打完后测了一下，居然所有样例一遍过。 最后 5 min 检查了一下，感觉没问题，抱着 160 分的期望成绩，等待着我的 OI 生涯的最后时刻的到来。 而成绩出来之后，却是另一番苦涩，第一题最后用于计数的桶没有清零，导致挂了 70 分，第二题最暴力的点没有换行，导致一分没得，最后一共挂了 130 ，实得 30 分。这是如此的令人绝望。 考后 当天其实我并没有表现过的悲伤，下午还是和同机房的人出去掇了台球，就当是赛后的放松了，顺带还叫上了之前的故友 GGapa。 其实在此刻我已经做好抱零的准备了（虽然没有，但似乎更让我感到悲痛）。 感言 先说寄语 对于后来人，如果你是真心地热爱竞赛，那么不管你是从什么时候开始，希望你能坚持下去；如果你只是为了升学，倘如在你走不下去时，还是尽早放弃为妙。 对于不同时期开始的同学，我认为应该有不同的目标。 保送的名额一年就几十个，谁都不能说自己是稳的，如果你是高中或初三才开始认真学，认清自己，定好目标。也许省一已是最好的归宿。 再说建议 先认清楚你学竞赛的目标，要有长期的规划，什么时候学什么，什么时候练习，什么时候打比赛（强校同学可以无视，一般教练都帮你们规划好了）。 不要摸鱼，这个太重要了，尤其是在做题做到一半时，会打断自己的思路，长期这样还会养成糟糕的思维习惯，导致注意力难以集中，不但影响竞赛，还有文化课。 系统刷题，在学习新算法或练习期间，不要盲目刷题，如果一段时间你在搞数据结构，你就认真地搞，不要因为看到一道别的知识点的好题（或水题），就转移目标，如果真的想做，可以加到做题计划中去，等以后在补。 不要划水，如果一道题，当你选择了要做他时，就一定要把他做出来（只要是在自己能力范围内），这样的题对个人的实力提升是巨大的，因为长时间没有做出来代表了自己的思维盲区，将其消灭，方能取得进步。 赛后改错，这点有多重要我不必多说。如果是想到了正解，但没做出来，建议好好看看自己的代码，找出造成自己漏洞的原因；但如果连正解都没想到，建议好好整理一下思路和过程，最好写一篇题解（可以不发出来，只写给自己看）。不管一道题做没做出来，都建议整理一下结论的证明过程（尤其是贪心和构造这种题目）。 保持谦卑，不要觉得自己实力很强，山外有山，人外有人，每一次我见到新的高手都会刷新我的认知，做好自己，不要因为一次成绩就无法无天，对新的算法，新的 trick 保持一种渴望。 深度挖掘，这个可以说是这几点中最重要的，一个算法，学了之后不但要搞清楚原理，还有模板，扩展以及和其他算法的融合，不要想当然的认为自己会了，便开始学习新的内容。 不留余地，作为一个竞赛生，真的不一定能走出来，但在选择路时不要给自己留余地，不要为了升学才选择 OI，在学的过程中，要学就认真学，耽误 WHK 就耽误，如果连这点代价都承担不了，还有什么必要学 OI 呢？ 以上几点都是结合我的个人经历来的，也是导致我从一个万众瞩目的种子选手到一无是处的废物所没有遵循的，也许这里面有运气和个人的原因，但事实证明，在竞赛这方面，可以说选择大于努力。 最后说一下个人经历 本人于高二遗憾退役（2024.11.30）。 要说初次接触编程，还是在小学四升五的时候，当时我的父母想把我送进当地比较好的学校（下文称为 CW）, 但在面试考试的过程中因为不会表演才艺，遗憾落选。于是我的家长给我报了一个另一个学校（下文称为 SW）的夏令营（主要是搞 WHK 的），而那一周刚好有一节编程课，在此之前我就听说过编程是很高级的东西，上了那节课之后，便对 Python 产生了浓厚的兴趣。 后来一向理科比较好的我进入了当地另一所学校（下文称为 JX）的分校区，再此过程中我也在利用课余时间学习 Python, 在后来的一场由 CW 举办的比赛中（更竞赛题比起来，全是入机题）拿到了比较好的成绩，然后就被机构推荐去学习 C++。 自此，我苦涩如歌的 OI 生涯开始了。 小学第一次参考 CSP-J，不出意外初赛只拿了 30 分。因为当时那个机构的课程已经学完（其实就是把 C++ 的语法基础学完了），所以打算换一个机构。 后来我的家长选择了学而思网课的 C++ 课程，而事实证明这无疑是一个错误的选择。一周两个小时的听课时间，十分钟的刷题量，学了一年也没有什么起色。后来小升初，因为强制要求大摇号，导致不敢去摇知名的学校（虽然我的成绩是可以考上的），只能选择一个才开两年且承诺非常好的学校（下文称 DC），然而这才是最错误的选择。 在临近我初一 CSP-J 时，我的家长将我送到了当地的科普基地进行学习，","categories":[{"name":"闲话","slug":"闲话","permalink":"http://stairsupon.github.io/categories/%E9%97%B2%E8%AF%9D/"}],"tags":[{"name":"鲜花","slug":"鲜花","permalink":"http://stairsupon.github.io/tags/%E9%B2%9C%E8%8A%B1/"},{"name":"感言","slug":"感言","permalink":"http://stairsupon.github.io/tags/%E6%84%9F%E8%A8%80/"}]},{"title":"题解：P11243 繁花","slug":"P11243flowers","date":"2024-11-05T11:44:00.000Z","updated":"2025-01-21T06:55:56.913Z","comments":true,"path":"2024/11/05/P11243flowers/","permalink":"http://stairsupon.github.io/2024/11/05/P11243flowers/","excerpt":"","text":"这是一篇图论做法题解 闲话：我看到基本上都是动态规划做法，但我考场上第一时间想到了图论，并且个人认为图论做法更好想到一些，故写此题解。 思路 首先，容易知道对于一个点的贡献，可以认为是一定比该点小的点的个数，而在这里很容易想到可以从该点连边到比该直接点小的点（即题目描述中直接用 或 连接的点），而题目描述中出现若干的点值可能相等，我们可以将这些点合并为一个点并统计相同的个数，然后整体来乘比该点小的点的个数，这样可以用 的复杂度过掉此题。 方便理解，这里给出样例中最后一个的图。 具体实现 先根据题中给的大小关系建图，从大的点向小的连边，相等则合并（我用的是并查集，其实也可以用缩点），然后统计子树大小总和，该点的贡献即为该点的数量乘上子树大小总和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156/*g++ -o2 2.cpp -o c -std=c++14./c*/#include&lt;cstdio&gt;using namespace std;typedef long long ll;const int N=5e6+100;const int M=5e6+100;char *p1,*p2;char buf[100];#define nc() getchar()// #define nc() (p1==p2 &amp;&amp; (p2=(p1=buf)+fread(buf,1,100,stdin),p1==p2)?EOF:*p1++)inline void read(int &amp;x){ x=0; char ch=nc(); while(ch&lt;48 || ch&gt;57){ ch=nc(); } while(ch&gt;=48 &amp;&amp; ch&lt;=57){ x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-48; ch=nc(); } return ;}int tot;int head[N];struct edge{ int x; int y; int next;}e[M];int T;int n,m;int siz[N];int cnt[N];int son[N];int fa[N];int in[N];char s[N];int vis[N];ll ans;inline void init(){ tot=0; for(int i=1;i&lt;=n+10;i++){ siz[i]=0; cnt[i]=1; head[i]=-1; fa[i]=i; vis[i]=0; } return ;}inline void add(int x,int y){ e[tot].x=x; e[tot].y=y; e[tot].next=head[x]; head[x]=tot++; return ;}inline int find(int x){ while(fa[x]^x) x=fa[x]; return x;}inline void merge(int x,int y){ int a=find(x); int b=find(y); if(a!=b){ fa[b]=a; cnt[a]+=cnt[b]; cnt[b]=0; } return ;}void dfs(int x,int fa){ siz[x]=cnt[x]; for(int i=head[x];~i;i=e[i].next){ int y=e[i].y; if(y==fa)continue; if(!vis[y])dfs(y,x); siz[x]+=siz[y]; } if(!vis[x]){ ans+=ll(cnt[x]*(siz[x]-cnt[x])); vis[x]=1; } return ;}void debug_build(){ printf(\"\\n\"); printf(\"%d\\n\",tot); for(int i=0;i&lt;tot;i++){ int x=e[i].x; int y=e[i].y; // int w=e[i].w; printf(\"%d %d\\n\",x,y); } printf(\"\\n\"); return ;}int main(){ read(T); while(T--){ ans=0; read(n); init(); scanf(\"%s\",s); for(int i=1;i&lt;n;i++){ if(s[i-1]=='='){ merge(i,i+1); vis[i+1]=1; } } for(int i=1;i&lt;n;i++){ int x=find(i); int y=find(i+1); if(s[i-1]=='&lt;')add(y,x); else if(s[i-1]=='&gt;')add(x,y); } // debug_build(); for(int i=1;i&lt;=n;i++){ printf(\"%d %d \\n\",i,fa[i]); } for(int i=1;i&lt;=n;i++){ if(!vis[i])dfs(i,0); } printf(\"%lld\\n\",ans); } return 0;}/*113=&gt;&lt;&lt;=&lt;=&gt;=&gt;&lt;&gt;*/","categories":[{"name":"题解","slug":"题解","permalink":"http://stairsupon.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://stairsupon.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"凸轮","slug":"凸轮","permalink":"http://stairsupon.github.io/tags/%E5%87%B8%E8%BD%AE/"}]},{"title":"题解：P10940 舞动的夜晚","slug":"P10940swingnight","date":"2024-10-09T12:49:00.000Z","updated":"2025-01-21T07:40:02.962Z","comments":true,"path":"2024/10/09/P10940swingnight/","permalink":"http://stairsupon.github.io/2024/10/09/P10940swingnight/","excerpt":"","text":"闲话 基于本题没有题解，那我来水一发网络流，先声明一下，本篇题解可能有部分口胡现象（本人太菜不会证明，但结论是对的，感性理解一下）。 正文 本题的结果不能直接用网络流跑出来（至少我不能）。网络流的题重在建图，但这题不一样，他更多是在考察对残余网络的操作。 首先我们看这个东西和二分图匹配有点像所以先把图拆点然后画出来，如下。 显然这个图的最大流（最大匹配）是 ，即最多能选出三对组队的人，而选用后会对最大流造成影响的边是 。因为选了这几条边后会直接或间接占用其他的流量通道，所以在这个图中答案显然是上述几条边，但如果我们看下面这个图。 能删去的边就不是那三条了，而只有 ，两条，相比之下 这条边就不会造成影响了，因为 点可以通过选择 点原来必须经过的点，即可以走 这条边。 然后我们发现可以将所有的便分为三种： 必行边：要保证最大流不变的情况下必须流过的边。 可行边：要保证最大流不变情况下有选择余地的边，即要在若干条边中选择一条边作为要流过的边。 不行边：要保证最大流不变情况下不能有流量流过的边。 那么可以发现，在第一个图中， ,都是必行边，而其他三条都为不行边，而第二个图中，只有 是必行边，而 ,都是可行边。 对于任意一条用于匹配的边，经过观察可以发现（下文的强连通分量指在残余网络中求得的结果，即求强连通分量的算法在运行时只能跑有流量的边）： 若该边流量为一，且该边的两个点不位于一个强连通分量，该边为必行边。 若该边的两点位于同一强连通分量中，且该强连通分量中存在一条从左点指向右点的边，即该强连通分量中有已经匹配成功的点，该边为可行边。 若该边流量为零且两点并不位于同一强连通分量，该边为不行边。 接下来讲一下为什么可行边的定义如上，先看图。 首先图中四个点位于一个强连通分量（网络流要求双向建边），我们由强连通分量的定义，这四个点最后会位于一个可以互相到达的环中，而因为这个性质，在这个环中，最大流相当于选择若干条边刚好将整个环的点覆盖，是可以自由选择的。 可行边理解了，必行边和不行边的定义应该也明白了。 那整道题的思路也清晰了，在原二分图中跑最大流，然后在有流量的边上跑强连通分量，最后判定不行边。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219/*g++ -o2 P10940.cpp -o c -std=c++14.\\c*/#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int N=2e4+100;const int M=4e5+100;const int inf=0x3f3f3f3f;char *p1,*p2;char buf[100];// #define nc() getchar()#define nc() (p1==p2 &amp;&amp; (p2=(p1=buf)+fread(buf,1,100,stdin),p1==p2)?EOF:*p1++)inline void read(int &amp;x){ x=0; char ch=nc(); while(ch&lt;48 || ch&gt;57){ ch=nc(); } while(ch&gt;=48 &amp;&amp; ch&lt;=57){ x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-48; ch=nc(); } return ;}int tot;int head[N];struct edge{ // int x; int y; int f; int next;}e[M];int dep[N];int gap[N];int cur[N];int last;int dfn[N];int low[N];int cidx;int col[N];int nl,nr;int n,m;int s,t;int bri_sta;int top;int pri[N];int q[M];int stk[M];int _top;inline int max(int a,int b){return a&gt;b?a:b;}inline int min(int a,int b){return a&lt;b?a:b;}inline int ops(int x){return x^1;}void init(){ tot=0; memset(head,-1,sizeof(head)); s=0; t=nl+nr+1; return ;}inline void add(int x,int y,int f){ e[tot].y=y; e[tot].f=f; e[tot].next=head[x]; head[x]=tot++; return ;}inline void make(int x,int y,int f){ add(x,y,f); add(y,x,0); return ;}void debug(){ for(int i=0;i&lt;tot;i+=2){ int x=e[ops(i)].y; int y=e[i].y; int f=e[i].f; printf(\"%d %d %d \\n\",x,y,f); } return ;}void bfs(int start,int to){ memset(dep,-1,sizeof(dep)); int hh=0; int tt=1; q[hh]=to; dep[to]=0; gap[0]=1; while(hh!=tt){ int x=q[hh++]; if(hh==M)hh=0; for(int i=head[x];~i;i=e[i].next){ int y=e[i].y; if(dep[y]!=-1)continue; dep[y]=dep[x]+1; gap[dep[y]]++; q[tt++]=y; if(tt==M)tt=0; } } return ;}int find(int x,int to,int lim){ if(x==to)return lim; int flow=0; for(int i=cur[x];~i;i=e[i].next){ int y=e[i].y; int f=e[i].f; cur[x]=i; if(!f)continue; if(dep[y]+1==dep[x]){ int t=find(y,to,min(f,lim-flow)); if(t&gt;0){ e[i].f-=t; e[ops(i)].f+=t; flow+=t; } if(flow==lim)return flow; } } gap[dep[x]]--; if(!gap[dep[x]])dep[s]=n+1; dep[x]++; gap[dep[x]]++; return flow;}int ISAP(int start,int to){ int flow=0; bfs(start,to); while(dep[start]&lt;=n+1){ memcpy(cur,head,sizeof(head)); // for(int i=1;i&lt;=n+1000;i++)cur[i]=head[i]; flow+=find(start,to,inf); } return flow;}void tarjan(int x){ last++; dfn[x]=last; low[x]=last; stk[++_top]=x; for(int i=head[x];~i;i=e[i].next){ if(!e[i].f)continue; int y=e[i].y; if(!dfn[y]){ tarjan(y); low[x]=min(low[x],low[y]); } else if(!col[y])low[x]=min(low[x],dfn[y]); } if(dfn[x]==low[x]){ cidx++; while(_top){ int t=stk[_top--]; col[t]=cidx; if(t==x)break; } } return ;}int main(){ read(nl); read(nr); read(m); n=nl+nr+2; init(); for(int i=1;i&lt;=nl;i++)make(s,i,1); for(int i=1;i&lt;=nr;i++)make(i+nl,t,1); bri_sta=tot; for(int i=1;i&lt;=m;i++){ int x,y; read(x); read(y); y+=nl; make(x,y,1); } // debug(); // printf(\"%d\\n\",ISAP(s,t)); int ans=ISAP(s,t); for(int i=1;i&lt;=n;i++)if(!dfn[i])tarjan(i); for(int i=bri_sta;i&lt;tot;i+=2){ int x=e[ops(i)].y; int y=e[i].y; int f=e[i].f; if(f &amp;&amp; col[x]!=col[y]){ pri[++top]=(i-bri_sta)/2+1; } } printf(\"%d\\n\",top); for(int i=1;i&lt;=top;i++){ printf(\"%d \",pri[i]); } putchar('\\n'); return 0;}","categories":[{"name":"网络流","slug":"网络流","permalink":"http://stairsupon.github.io/categories/%E7%BD%91%E7%BB%9C%E6%B5%81/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://stairsupon.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"图论建模","slug":"图论建模","permalink":"http://stairsupon.github.io/tags/%E5%9B%BE%E8%AE%BA%E5%BB%BA%E6%A8%A1/"}]},{"title":"P10938 Vani和Cl2捉迷藏","slug":"P10938Vanicl","date":"2024-09-16T11:44:00.000Z","updated":"2025-01-21T07:49:44.433Z","comments":true,"path":"2024/09/16/P10938Vanicl/","permalink":"http://stairsupon.github.io/2024/09/16/P10938Vanicl/","excerpt":"","text":"闲话 基于本题已经有人写了匈牙利的题解，这里我就来写一篇关于网络流的题解。 能做这道题的人应该都能看出是裸的最小重复路径覆盖问题吧。 虽然最小路径覆盖原代码只会红一个点。 思路 首先网络流的难点一直都是在于建图，那么这道题该怎么建图呢？ 引入 先想一下普通的最小路径覆盖集问题，我们的见图方式是将每个点拆为出点和入点，目的是保证每个点刚好只被所有路径经过一次。 然后将源点和入点连接，汇点和出点连接（废话）。 对于原图中的连边 我们将 出点连接到 入点。 仔细考虑一下为什么这么建图，我的解释是这样的：对于最小路径覆盖我们肯定希望能用最少的路径覆盖不重不漏覆盖所有点，那么上面这种建图方式，可以再实际运行中像穿针引线一样把所有这条路径上是点用 的单位流量穿起来从起点引导到终点，而因为过程中限流，所以就算有多条边和改点相连，最后也只会穿到一条路径上，而跑满最大流的过程最好就是将上面所有的边 都跑上一的流量，刚好满足最大流的性质。 正解 最小路径覆盖和最小重复路径覆盖的区别在于，后者可以是一条边被多次覆盖，那该怎么办呢？ 其实唯一区别就是将原来的建边改为将一个点和它所有能沿着当前边能到达的点都连上有向边。 现在考虑为什么？ 因为是重复覆盖，因此可以有多条路径同起点或同终点，而原来一条路径可能会被另一条分成两条，而现在可以直接用两点表示一整条路径，故上述建图方式可行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187/*g++ -o2 P10938.cpp -o c -std=c++14.\\c*/#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;using namespace std;const int N=4e2+20;const int M=5e4+100;const int inf=0x3f3f3f3f;inline int max(int a,int b){return a&gt;b?a:b;}inline int min(int a,int b){return a&lt;b?a:b;}inline int ops(int x){return x^1;}int tot;int head[N];struct edge{ int y,f,w; int next;}e[M];int cur[N];int dep[N];int q[M];int in[N];int ou[N];int n,m;int s,t;int con[N][N];vector&lt;int&gt;v[N];char *p1,*p2;char buf[10];// #define nc getchar#define nc() (p1==p1 &amp;&amp; (p2=(p1=buf)+fread(buf,1,10,stdin),p1==p2)?EOF:*p1++)inline void read(int &amp;x){ int sum=0; char ch=nc(); while(ch&lt;48 || ch&gt;57){ ch=nc(); } while(ch&gt;=48 &amp;&amp; ch&lt;=57){ sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-48; ch=nc(); } x=sum; return ;}inline void add(int x,int y,int f){ e[tot].y=y; e[tot].f=f; e[tot].next=head[x]; head[x]=tot++; return ;}inline void make(int x,int y,int f){ add(x,y,f); add(y,x,0); return ;}inline bool bfs(int start,int to){ int hh=0; int tt=1; memset(dep,-1,sizeof(dep)); // for(int i=1;i&lt;=n*2+10;i++)dep[i]=-1; q[hh]=start; cur[start]=head[start]; dep[start]=0; while(hh!=tt){ int x=q[hh++]; if(tt==M)hh=0; for(int i=head[x];~i;i=e[i].next){ int y=e[i].y; int f=e[i].f; if(!f)continue; if(dep[y]==-1){ dep[y]=dep[x]+1; cur[y]=head[y]; if(y==to)return true; q[tt++]=y; if(tt==M)tt=0; } } } return false;}inline int find(int x,int to,int limit){ if(x==to)return limit; int flow=0; for(int i=cur[x];~i &amp;&amp; flow&lt;limit;i=e[i].next){ int y=e[i].y; int f=e[i].f; cur[x]=i; if(!f)continue; if(dep[y]==dep[x]+1){ int t=find(y,to,min(limit-flow,f)); if(!t)dep[y]=-1; e[i].f-=t; e[ops(i)].f+=t; flow+=t; } } return flow;}inline void dinic(int start,int to,int &amp;ans){ int flow=0; int r=0; while(bfs(start,to)){ while(flow=find(start,to,inf)){ r+=flow; } } ans=r; return ;}inline void init(){ tot=0; memset(head,-1,sizeof(head)); s=0; t=n*2+1; return ;}inline void debug_build(){ for(int i=0;i&lt;tot;i+=2){ int x=e[ops(i)].y; // int x=e[i].x; int y=e[i].y; int f=e[i].f; // int w=e[i].w; printf(\"%d -&gt; %d :%d\\n\",x,y,f); } return ;}inline void dfs(int x,int fro){ for(int i=0;i&lt;v[x].size();i++){ int y=v[x][i]; if(con[fro][y])continue; con[fro][y]=1; // con[y][fro]=1; dfs(y,fro); } return ;}int main(){ scanf(\"%d%d\",&amp;n,&amp;m); init(); for(int i=1;i&lt;=m;i++){ int x,y; scanf(\"%d%d\",&amp;x,&amp;y); v[x].push_back(y); } for(int i=1;i&lt;=n;i++){ dfs(i,i); for(int j=1;j&lt;=n;j++){ if(con[i][j]){ make(i+n,j,1); } } } for(int i=1;i&lt;=n;i++){ make(s,i+n,1); make(i,t,1); } int ans; // debug_build(); dinic(s,t,ans); printf(\"%d\\n\",n-ans); return 0;} 最后祝喜欢瓦尼瓦尼的 能早日水神满命。","categories":[{"name":"网络流","slug":"网络流","permalink":"http://stairsupon.github.io/categories/%E7%BD%91%E7%BB%9C%E6%B5%81/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://stairsupon.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"图论建模","slug":"图论建模","permalink":"http://stairsupon.github.io/tags/%E5%9B%BE%E8%AE%BA%E5%BB%BA%E6%A8%A1/"}]},{"title":"题解：P11021 「LAOI-6」区间测速","slug":"P11021speedtest","date":"2024-09-08T05:10:00.000Z","updated":"2025-01-21T08:00:25.009Z","comments":true,"path":"2024/09/08/P11021speedtest/","permalink":"http://stairsupon.github.io/2024/09/08/P11021speedtest/","excerpt":"","text":"题意简化 每次修改一个点的横坐标，求斜率最大值 如何思考 首先考虑，如果没有修改操作，只是单纯的问你任意两点之间的斜率，该怎么办？ 暴力 这里有一个 的做法是任意点都算一遍求最大斜率但显然不可能。 优化 其实学过斜率优化的都知道可以先以横坐标为关键词排个序（可以理解为在坐标轴上画出来），然后要求的任意两点的斜率最大值就是是排序后相邻两点的斜率的最大值。 那没学过怎么办，这里来证明： 对于上面这张图，我们将要处理的点在坐标轴上描出来（在程序里体现为排序），显然直线 的斜率最大，在程序内部点都已经排好序，当处理到点 时发现前一个点和当前点的斜率大于当前已知的最大斜率，即 于是将当前的最大值更改。 接下来是疑点，为啥最大斜率一定是相邻两点的，图中可以看出 ，我们假设有三个点 那可以得出 ,。 通过计算可以得到若 , 就一定会有 。 所以得出以上结论。 该怎么用 其实加上修改之后我们发现每次修改真正影响到的只有两个点即前面的点和后面的点，于是我们可以预处理出不修改时的最大斜率，再每次和修改后的点产生的贡献（即修改后位置前后的斜率）对比取最大值，求解。 但有一个问题如果修改影响到最大值怎么办，其实只需要再处理出次大值就可以了。 注意不是直接求次大值，是要求和最大值没有公共点的次大值 最后判断一下即可，注意要判断修改到最前面和最后面的情况。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/*g++ -o2 3.cpp -o c -std=c++14.\\c*/#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;const int N=5e5+100;int n,m;int max(int a,int b){return a&gt;b?a:b;}int min(int a,int b){return a&lt;b?a:b;}int abs(int a){return a&gt;0?a:-a;}struct node{ int x,t; int id; bool operator &lt; (const node s){ if(t!=s.t)return t &lt; s.t; return x &lt; s.x; }}e[N];int max_fir;int max_sec;int fro_fir;int fro_sec;int tim[N];int find(int t){ int l=1; int r=n; if(t&lt;e[1].t)return 0; if(t&gt;e[n].t)return n+1; while(l&lt;r){ int mid=(l+r)&gt;&gt;1; if(e[mid].t&gt;=t)r=mid; else l=mid+1; } return l;}int main(){ scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++){ scanf(\"%d%d\",&amp;e[i].x,&amp;e[i].t); tim[i]=e[i].t; } sort(e+1,e+n+1); for(int i=2;i&lt;=n;i++){ // int w= int d=abs(e[i].x-e[i-1].x)/abs(e[i].t-e[i-1].t); if(d&gt;max_fir){ if(fro_fir!=i-1){ max_sec=max_fir; fro_sec=fro_fir; } max_fir=d; fro_fir=i; } else if(d&gt;max_sec){ if(fro_fir!=i-1){ max_sec=d; fro_sec=i; } } } // return 0; int ans; for(int i=1;i&lt;=m;i++){ int u,v; ans=0; scanf(\"%d%d\",&amp;u,&amp;v); u=tim[u]; // printf(\"%d\\n\",u); int d=find(u); int tmp=find(v); int tx=e[d].x; // if(v==e[tmp].t)tmp++; int d1=0; int d2=0; if(tmp==0){ int www=abs(v-e[tmp].t); if(www==0)d2=0; else d2=abs(tx-e[tmp].x)/www; } else if(tmp==n+1){ int www=abs(v-e[tmp-1].t); if(www==0)d2=0; else d1=abs(tx-e[tmp-1].x)/www; // printf(\"d1: %d\\n\",d1); } else { int www=abs(v-e[tmp].t); if(www==0)d2=0; else d2=abs(tx-e[tmp].x)/abs(v-e[tmp].t); www=abs(v-e[tmp-1].t); if(www==0)d2=0; else d1=abs(tx-e[tmp-1].x)/www; } ans=max(d1,d2); // printf(\"%d %d\\n\",d,fro_fir); if(d!=fro_fir &amp;&amp; d!=fro_fir-1){ ans=max(ans,max_fir); } else { ans=max(ans,max_sec); } // printf(\"%d\\n\",d); // printf(\"%d\\n\",tmp); printf(\"%d\\n\",ans); } // for(int i=1;i&lt;=n;i++){ // printf(\"%d %d \\n\",e[i].t,e[i].x); // } return 0;}","categories":[{"name":"-二分","slug":"二分","permalink":"http://stairsupon.github.io/categories/%E4%BA%8C%E5%88%86/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://stairsupon.github.io/tags/%E4%BA%8C%E5%88%86/"},{"name":"贪心","slug":"贪心","permalink":"http://stairsupon.github.io/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"P9384 [THUPC 2023 决赛] 着色","slug":"P9384color","date":"2024-08-10T00:16:00.000Z","updated":"2025-01-21T09:40:16.034Z","comments":true,"path":"2024/08/10/P9384color/","permalink":"http://stairsupon.github.io/2024/08/10/P9384color/","excerpt":"","text":"P9384 构造题，首先考虑爆搜，但结果跑不出来。 既然题目中描述相同元素不能构成三元环或五元环，其实可以把条件用的更局限，考虑相同元素只能构成偶环，即同一权值的边构成二分图，可以发现本题刚好 种颜色，刚好 。 接下来考虑怎么构造二分图，本题大部分思路都是令 ，并将 作为染色的依据，但没有提到怎么去想出这样的思路。 首先，令一个集合 ，其中的元素互不相同,且都不为零。 令另一个集合 ，其中 且 满足 ，特别地 。 说人话就是集合 是由集合 中两个相邻的元素异或得到的。 对于以上两个集合有一个性质：即当 为偶数时，对于形式类似于 的情况刚好能不重不漏的覆盖整个 集合，具体请读者自证。 那以上结论有什么用呢？可以发现在一个二分图里面，点数刚好是偶数，而每个点的序都不同，刚好满足上述条件，故可以按照思路中的 作为染色的依据。 123456789101112131415161718192021222324252627282930/*g++ -o2 P9384.cpp -o c -std=c++14.\\c*/#include&lt;cstdio&gt;using namespace std;const int N=1e3+100;int n;int t[N];int lowbit(int x){ return x&amp;(-x);}int main(){ scanf(\"%d\",&amp;n); for(int i=0;i&lt;=10;i++){ t[1&lt;&lt;i]=i; } for(int i=1;i&lt;n;i++){ for(int j=i+1;j&lt;=n;j++){ printf(\"%d\",t[lowbit(i^j)]); } printf(\"\\n\"); } return 0;}","categories":[],"tags":[{"name":"构造","slug":"构造","permalink":"http://stairsupon.github.io/tags/%E6%9E%84%E9%80%A0/"}]}],"categories":[{"name":"闲话","slug":"闲话","permalink":"http://stairsupon.github.io/categories/%E9%97%B2%E8%AF%9D/"},{"name":"题解","slug":"题解","permalink":"http://stairsupon.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"网络流","slug":"网络流","permalink":"http://stairsupon.github.io/categories/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"-二分","slug":"二分","permalink":"http://stairsupon.github.io/categories/%E4%BA%8C%E5%88%86/"}],"tags":[{"name":"鲜花","slug":"鲜花","permalink":"http://stairsupon.github.io/tags/%E9%B2%9C%E8%8A%B1/"},{"name":"感言","slug":"感言","permalink":"http://stairsupon.github.io/tags/%E6%84%9F%E8%A8%80/"},{"name":"题解","slug":"题解","permalink":"http://stairsupon.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"凸轮","slug":"凸轮","permalink":"http://stairsupon.github.io/tags/%E5%87%B8%E8%BD%AE/"},{"name":"网络流","slug":"网络流","permalink":"http://stairsupon.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"图论建模","slug":"图论建模","permalink":"http://stairsupon.github.io/tags/%E5%9B%BE%E8%AE%BA%E5%BB%BA%E6%A8%A1/"},{"name":"二分","slug":"二分","permalink":"http://stairsupon.github.io/tags/%E4%BA%8C%E5%88%86/"},{"name":"贪心","slug":"贪心","permalink":"http://stairsupon.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"构造","slug":"构造","permalink":"http://stairsupon.github.io/tags/%E6%9E%84%E9%80%A0/"}]}