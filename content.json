{"meta":{"title":"Stairs_upon_temple","subtitle":"","description":"","author":"Stairs_upon_temple","url":"http://stairsupon.github.io","root":"/"},"pages":[{"title":"","date":"2025-01-21T01:36:46.026Z","updated":"2025-01-21T01:36:46.026Z","comments":true,"path":"404/index.html","permalink":"http://stairsupon.github.io/404/index.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2025-01-21T01:40:21.994Z","updated":"2025-01-21T01:40:21.994Z","comments":true,"path":"about/index.html","permalink":"http://stairsupon.github.io/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"所有分类","date":"2025-01-21T01:35:33.657Z","updated":"2025-01-21T01:35:33.657Z","comments":true,"path":"categories/index.html","permalink":"http://stairsupon.github.io/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2025-01-21T01:35:54.497Z","updated":"2025-01-21T01:35:54.497Z","comments":true,"path":"friends/index.html","permalink":"http://stairsupon.github.io/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有标签","date":"2025-01-21T01:35:21.232Z","updated":"2025-01-21T01:35:21.232Z","comments":true,"path":"tags/index.html","permalink":"http://stairsupon.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2025-01-21T00:34:43.021Z","updated":"2025-01-21T01:53:50.576Z","comments":true,"path":"2025/01/21/hello-world/","permalink":"http://stairsupon.github.io/2025/01/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"题解：P11243 繁花","slug":"flowers","date":"2024-11-05T11:44:00.000Z","updated":"2025-01-21T06:55:56.913Z","comments":true,"path":"2024/11/05/flowers/","permalink":"http://stairsupon.github.io/2024/11/05/flowers/","excerpt":"","text":"这是一篇图论做法题解 闲话：我看到基本上都是动态规划做法，但我考场上第一时间想到了图论，并且个人认为图论做法更好想到一些，故写此题解。 思路 首先，容易知道对于一个点的贡献，可以认为是一定比该点小的点的个数，而在这里很容易想到可以从该点连边到比该直接点小的点（即题目描述中直接用 或 连接的点），而题目描述中出现若干的点值可能相等，我们可以将这些点合并为一个点并统计相同的个数，然后整体来乘比该点小的点的个数，这样可以用 的复杂度过掉此题。 方便理解，这里给出样例中最后一个的图。 具体实现 先根据题中给的大小关系建图，从大的点向小的连边，相等则合并（我用的是并查集，其实也可以用缩点），然后统计子树大小总和，该点的贡献即为该点的数量乘上子树大小总和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156/*g++ -o2 2.cpp -o c -std=c++14./c*/#include&lt;cstdio&gt;using namespace std;typedef long long ll;const int N=5e6+100;const int M=5e6+100;char *p1,*p2;char buf[100];#define nc() getchar()// #define nc() (p1==p2 &amp;&amp; (p2=(p1=buf)+fread(buf,1,100,stdin),p1==p2)?EOF:*p1++)inline void read(int &amp;x){ x=0; char ch=nc(); while(ch&lt;48 || ch&gt;57){ ch=nc(); } while(ch&gt;=48 &amp;&amp; ch&lt;=57){ x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-48; ch=nc(); } return ;}int tot;int head[N];struct edge{ int x; int y; int next;}e[M];int T;int n,m;int siz[N];int cnt[N];int son[N];int fa[N];int in[N];char s[N];int vis[N];ll ans;inline void init(){ tot=0; for(int i=1;i&lt;=n+10;i++){ siz[i]=0; cnt[i]=1; head[i]=-1; fa[i]=i; vis[i]=0; } return ;}inline void add(int x,int y){ e[tot].x=x; e[tot].y=y; e[tot].next=head[x]; head[x]=tot++; return ;}inline int find(int x){ while(fa[x]^x) x=fa[x]; return x;}inline void merge(int x,int y){ int a=find(x); int b=find(y); if(a!=b){ fa[b]=a; cnt[a]+=cnt[b]; cnt[b]=0; } return ;}void dfs(int x,int fa){ siz[x]=cnt[x]; for(int i=head[x];~i;i=e[i].next){ int y=e[i].y; if(y==fa)continue; if(!vis[y])dfs(y,x); siz[x]+=siz[y]; } if(!vis[x]){ ans+=ll(cnt[x]*(siz[x]-cnt[x])); vis[x]=1; } return ;}void debug_build(){ printf(\"\\n\"); printf(\"%d\\n\",tot); for(int i=0;i&lt;tot;i++){ int x=e[i].x; int y=e[i].y; // int w=e[i].w; printf(\"%d %d\\n\",x,y); } printf(\"\\n\"); return ;}int main(){ read(T); while(T--){ ans=0; read(n); init(); scanf(\"%s\",s); for(int i=1;i&lt;n;i++){ if(s[i-1]=='='){ merge(i,i+1); vis[i+1]=1; } } for(int i=1;i&lt;n;i++){ int x=find(i); int y=find(i+1); if(s[i-1]=='&lt;')add(y,x); else if(s[i-1]=='&gt;')add(x,y); } // debug_build(); for(int i=1;i&lt;=n;i++){ printf(\"%d %d \\n\",i,fa[i]); } for(int i=1;i&lt;=n;i++){ if(!vis[i])dfs(i,0); } printf(\"%lld\\n\",ans); } return 0;}/*113=&gt;&lt;&lt;=&lt;=&gt;=&gt;&lt;&gt;*/","categories":[{"name":"题解","slug":"题解","permalink":"http://stairsupon.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://stairsupon.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"凸轮","slug":"凸轮","permalink":"http://stairsupon.github.io/tags/%E5%87%B8%E8%BD%AE/"}]}],"categories":[{"name":"题解","slug":"题解","permalink":"http://stairsupon.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://stairsupon.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"凸轮","slug":"凸轮","permalink":"http://stairsupon.github.io/tags/%E5%87%B8%E8%BD%AE/"}]}