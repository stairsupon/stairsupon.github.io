{"meta":{"title":"Stairs_upon_temple","subtitle":"","description":"","author":"Stairs_upon_temple","url":"http://stairsupon.github.io","root":"/"},"pages":[{"title":"所有分类","date":"2025-01-21T01:35:33.657Z","updated":"2025-01-21T01:35:33.657Z","comments":true,"path":"categories/index.html","permalink":"http://stairsupon.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2025-01-22T08:50:48.159Z","updated":"2025-01-22T08:50:48.159Z","comments":true,"path":"about/index.html","permalink":"http://stairsupon.github.io/about/index.html","excerpt":"","text":"说一下个人经历 关于OI 本人于高二遗憾退役（2024.11.30）。 要说初次接触编程，还是在小学四升五的时候，当时我的父母想把我送进当地比较好的学校（下文称为 CW）, 但在面试考试的过程中因为不会表演才艺，遗憾落选。于是我的家长给我报了一个另一个学校（下文称为 SW）的夏令营（主要是搞 WHK 的），而那一周刚好有一节编程课，在此之前我就听说过编程是很高级的东西，上了那节课之后，便对 Python 产生了浓厚的兴趣。 后来一向理科比较好的我进入了当地另一所学校（下文称为 JX）的分校区，再此过程中我也在利用课余时间学习 Python, 在后来的一场由 CW 举办的比赛中（跟竞赛题比起来，全是入机题）拿到了比较好的成绩，然后就被机构推荐去学习 C++。 自此，我苦涩如歌的 OI 生涯开始了。 小学第一次参考 CSP-J，不出意外初赛只拿了 30 分。因为当时那个机构的课程已经学完（其实就是把 C++ 的语法基础学完了），所以打算换一个机构。 后来我的家长选择了学而思网课的 C++ 课程，而事实证明这无疑是一个错误的选择。一周两个小时的听课时间，十分钟的刷题量，学了一年也没有什么起色。后来小升初，因为强制要求大摇号，导致不敢去摇知名的学校（虽然我的成绩是可以考上的），只能选择一个才开两年且承诺非常好的学校（下文称 DC），然而这才是最错误的选择。 在临近我初一 CSP-J 时，我的家长将我送到了当地的科普基地进行学习，当时才了解到算法知识体系的庞大，在那里虽然一开始被薄纱，但慢慢的还是有些起色。 后来刚升到初二时，勉强拿到了一个普及组的二等（差点一等），经人介绍兜兜转转又回到了 CW 学习信竞，而那一个寒假，我基本都在 CW 学习，也是从当时最差的赶到了比较靠前面（除了当时几个一批的学生），而当时的教练也比较看好我，而寒假结束之后问题就来了： CW 那里每周周六上一整天的课，而我们的出生学校 DC 对英才班的要求是周五不放学，周六中午放，这就导致了我的周六上午必须在 OI 和 WHK 之间选一个，但当时我的 WHK 成绩还可以，所以我向当时我的班主任提出了周六不来的想法，不但遭到拒绝，还被狠批一顿，本来在初中的时候就比较调皮，而这次之后更是直接让我改变了立场，直接导致了后来的一些悲剧。 但是好在我个人还是比较上进，缺半天的课能达到别人上一天的效果，还是跟了半年，最后在初三擦边拿到普及一等，但这仍是当时我们学校的最好成绩，现在想放弃放不下，想继续有看不到希望，后来我们自己的学校开设竞赛课，本来当时已经想放弃，而 DC 那位抽象的主任（有介绍的）还是强行把我拉进来，每周只有 2 hour 的时间学习，而他自己又不来守，因为我们自控力太差导致信竞教室变为电竞教室，最后白白浪费了一年学习时间，但其实就算加上这些时间，也摆脱不了命运。 而上了高中，好了一些，换了个人来当教练，但主管我们的主人还是那个抽象的人，高中给的时间相对多一些，自然也是有所好转，但到后面停课的时候，那位主任再次发力，导致我们无法停课，当时我们班主任觉得我很有希望，主动去找校长来申请此事，而那个主任也是怕担责，以各种理由来阻止，甚至说我们文化课老师，以及教练的坏话。 后来文化课压得紧，外加状态不好最后也是没有拿到理想成绩，就这样不了了之，实在不甘心，我的失败可以说怪自己，怪选择，但主要还是得说一下运气，命运一次又一次将我推向失败，总是在最后给我致命一击，但这都无法阻挡我，因为我还有支持我的家人，我的信念还是坚定如初。"},{"title":"我的朋友们","date":"2025-01-21T01:35:54.497Z","updated":"2025-01-21T01:35:54.497Z","comments":true,"path":"friends/index.html","permalink":"http://stairsupon.github.io/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有标签","date":"2025-01-21T01:35:21.232Z","updated":"2025-01-21T01:35:21.232Z","comments":true,"path":"tags/index.html","permalink":"http://stairsupon.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2025-01-21T01:36:46.026Z","updated":"2025-01-21T01:36:46.026Z","comments":true,"path":"404/index.html","permalink":"http://stairsupon.github.io/404/index.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"}],"posts":[{"title":"tulun","slug":"tulun","date":"2025-01-22T00:53:36.000Z","updated":"2025-01-22T01:03:15.132Z","comments":true,"path":"2025/01/22/tulun/","permalink":"http://stairsupon.github.io/2025/01/22/tulun/","excerpt":"","text":"最短路 SPFA 12345678910111213141516171819202122232425void spfa(int start){ queue&lt;int&gt;q; memset(dis,0x3f,sizeof(dis)); memset(cis,0x3f,sizeof(cis)); dis[start]=0; q.push(start); while(!q.empty()){ int x=q.front(); q.pop(); vis[x]=0; for(int i=head[x];~i;i=e[i].next){ int y=e[i].y; int w=e[i].w; if(dis[y]&gt;dis[x]+w){ dis[y]=dis[x]+w; if(!vis[y]){ vis[y]=1; q.push(y); } } } } return ;} dij 12345678910111213141516171819202122232425262728struct edge{ int x,w; bool operator &lt;(const edge &amp;s)const{ return w &gt; s.w; }};void dij(int start){ memset(dis,0x3f,sizeof(dis)); priority_queue&lt;edge&gt;q; dis[start]=0; q.push(edge{start,dis[start]}); while(!q.empty()){ int x=q.top().x; q.pop(); if(vis[x])continue; vis[x]=1; for(int i=head[x];~i;i=e[i].next){ int y=e[i].y; int w=e[i].w; if(dis[y]&gt;dis[x]+w){ dis[y]=dis[x]+w; q.push(edge{y,dis[y]}); } } } return ;} LCA 倍增 问题：输入一棵n个结点的树，以及m组请求，每个请求是两个结点，求它们的最小公共祖先。 实现思路：先建树，求出每一个点的深度，再根据深度来求lca。 具体实现： 建树求深度，并求出每个点的父节点，方便后面进行跳点、 接下来考虑如何查找最近公共祖先，可以先将两个点升到同一高度，再同时往上跳，但这么做的时间复杂度为O(nm)肯定会超时。这里我用ST表进行优化。 优化思路：下面是一个树，如果我们要求6号节点和7号节点lca，我们可以先列出一个式子，表示第i层时他们的祖先节点是否是同一个点。 如图列出式子如下：F F F T T T 可以看出当第一次达到T时，该点为两点的最近公共祖先。 那我们用ST表记录st[x][i]表示向上跳2^i个点,跳了之后如果该点为两点的祖先节点就换更小的i来跳，反之则将x,y更替为st[x][i],st[y][i]。通过这种方式来进行提速，单次lca的时间复杂度为O(logn),总体时间复杂度为O(mlogn)。 1234567//st表初始化void init(){ for(int i=1;i&lt;=n;i++)st[i][0]=fa[i]; for(int j=1;(1&lt;&lt;j)&lt;=n;j++){ for(int i=1;i&lt;=n;i++)st[i][j]=st[st[i][j-1]][j-1]; }} 1234567891011121314//lca模版int lca(int x,int y){ if(deep[x]&lt;deep[y]){ int tp=x;x=y;y=tp; }int t=deep[x]-deep[y],i=0; while(t){ if(t%2==1)x=st[x][i]; t=t&gt;&gt;1;i++; }if(x==y)return x; for(int i=logn;i&gt;=0;i--){ if(st[x][i]==st[y][i])continue; x=st[x][i];y=st[y][i]; }return st[x][0];} 最后完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;const int N=1e6+100;struct node{ int y,nx;}e[N];int n,m,last,logn;int head[N];int fa[N];int deep[N];int st[N][30];void add(int x,int y){ last++; e[last].y=y; e[last].nx=head[x]; head[x]=last; return ;}void dfs(int x,int _fa){ fa[x]=_fa; deep[x]=deep[_fa]+1; for(int i=head[x];i;i=e[i].nx){ int y=e[i].y; if(y==_fa)continue; dfs(y,x); } return ;}void init(){ for(int i=1;i&lt;=n;i++)st[i][0]=fa[i]; for(int j=1;(1&lt;&lt;j)&lt;=n;j++) for(int i=1;i&lt;=n;i++)st[i][j]=st[st[i][j-1]][j-1]; return ;}int lca(int x,int y){ if(deep[x]&lt;deep[y]){ int tp=x; x=y; y=tp; } int t=deep[x]-deep[y],i=0; while(t){ if(t%2==1)x=st[x][i]; t=t&gt;&gt;1;i++; } if(x==y)return x; for(int i=logn;i&gt;=0;i--){ if(st[x][i]==st[y][i])continue; x=st[x][i];y=st[y][i]; } return st[x][0];}int main(){ scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;n;i++){ int a,b; scanf(\"%d%d\",&amp;a,&amp;b); add(a,b); add(b,a); } dfs(1,0); init(); logn=log2(n); for(int i=1;i&lt;=m;i++){ int a,b; scanf(\"%d%d\",&amp;a,&amp;b); printf(\"%d\\n\",lca(a,b)); } return 0;} 树链剖分 1.若x所在的重链的链头不等于y所在的重链的链头，表明x和y不在同一条重链上 2.记x和y两点中链头的深度较深的那个点为z 3.将z调到他的链头的father 4.重复以上步骤，知道x与y的链头相等（即在同一条重链上） 5.此时x和y中深度较小的那个点即为LCA 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/*g++ -o2 slpf.cpp -o c -std=c++14.\\c*/#include&lt;cstdio&gt;using namespace std;typedef long long ll;const int N=5e6+100;int tot;int head[N];struct node{ int y,next;}e[N];int fa[N];int dep[N];int son[N];int siz[N];int dfn[N];int top[N];int n,m,s;void swap(int &amp;x,int &amp;y){ int t=x; x=y; y=t; return ;}void add(int x,int y){ tot++; e[tot].y=y; e[tot].next=head[x]; head[x]=tot; return ;}void dfs_f(int x,int _fa){ /* 第一次跑DFS,将每个点的父节点，深度，子节点个数算出来 并计算出每个点的最大的子节点，当作重儿子 */ fa[x]=_fa; siz[x]=1; dep[x]=dep[_fa]+1; int son_max=0; for(int i=head[x];i;i=e[i].next){ int y=e[i].y; if(y==_fa)continue; dfs_f(y,x); siz[x]+=siz[y]; if(siz[y]&gt;son_max){ son[x]=y; son_max=siz[y]; } } return ;}void dfs_s(int x,int fa_top){ /* 第二次跑DFS，按照上一次跑出来的重儿子优先遍历 将整个树分成若干条链，并求出每条链的链顶 */ top[x]=fa_top; if(son[x])dfs_s(son[x],fa_top); for(int i=head[x];i;i=e[i].next){ int y=e[i].y; if(y==fa[x])continue; if(y==son[x])continue; dfs_s(y,y); } return ;}int lca(int x,int y){ while(top[x]!=top[y]){ if(dep[top[x]]&lt;dep[top[y]])swap(x,y); x=fa[top[x]]; } return dep[x]&lt;dep[y]?x:y;}int main(){ scanf(\"%lld%lld%lld\",&amp;n,&amp;m,&amp;s); for(int i=1;i&lt;n;i++){ int x,y; scanf(\"%lld%lld\",&amp;x,&amp;y); add(x,y); add(y,x); } // printf(\"a\\n\"); dfs_f(s,0); // printf(\"s\\n\"); dfs_s(s,s); // printf(\"d\\n\"); for(int i=1;i&lt;=m;i++){ int x,y; scanf(\"%lld%lld\",&amp;x,&amp;y); printf(\"%lld\\n\",lca(x,y)); } return 0;} ———————————————— 联通分量 强联通分量 （tarjan） 有向图的极大强连通子图称为的强连通分量，强连通图只有一个强连通分量，即是其自身。非强连通的有向图有多个强连通分量，这里我介绍一种用tarjan的求强连通分量方法。 实现思路: 首先先建图，然后在遍历的过程中对每个点的访问顺序打上标记。结果如下: 可以看出2-&gt;3-&gt;6-&gt;4为一个强连通分量，那么接下来考虑如何将该连通分量的点值化为一个相同的数。 这里可以建两个数组dfn和low，dfn用来记录该点在遍历时的顺序，low则用来记录该点所在的连通分量的顺序。 那么该如何判断遍历过的点是否在一个连通分量上呢？因为连通分量上的点可以互相到达，又因为是有向图，所以强连通分量要么是一个点要么是一个环。即如果在访问的过程中找到一个访问过的点，就在回溯过程中将路径上点的low全部化为一个可以代表整个连通分量的数字，即访问该连通分量时的第一个访问的数字。 实现代码如下 ： 1234567891011121314void tarjan(int x){ last++; dfn[x]=last; low[x]=last; vis[x]=1; for(int i=head[x];i;i=e[i].next){ int y=e[i].y; if(!dfn[y]){ tarjan(y); low[x]=min(low[x],low[y]); }else if(vis[x]==1) low[x]=min(low[x],dfn[y]); }vis[x]=2;} 但实际上这个代码是有问题的如果出现连个环共用两个及以上的点的话，后遍历的环就会被分成多个连通分量，如图： 在这个图中7会被划分成一个额外的连通分量而不是和2-&gt;3-&gt;6-&gt;4划为一个整体， 为了解决这个问题，在这里我们可以用一个color数组去记录每个点所属的连通分量，通过判断下一个遍历点是否处于同一色块来判断是非需要划分。 在遍历的过程中可以用一个栈来存储已经遍历过的点，在发现low[x]==dfn[x]时将栈里面的点都划上颜色，即到达该连通分量的第一点时进行划分。 1234567891011121314151617181920void tarjan(int x){ last++; dfn[x]=last; low[x]=last; stk.push(x); for(int i=head[x];i;i=e[i].next){ int y=e[i].y; if(!dfn[y]){ tarjan(y); low[x]=min(low[x],low[y]); }else if(color[y]==0)low[x]=min(low[x],dfn[y]); }if(dfn[x]==low[x]){//判断是否位于该连通分量第一点 ++cidx;//新增一个颜色 while(!stk.empty()){ int t=stk.top();stk.pop(); color[t]=cidx;//上色 if(t==x)break;//染色完后退出 } }} 最后输出每一个连通块遍历完后的颜色总数，完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;stack&gt;using namespace std;const int N=1e5+100;int n,m;struct node{ int y,next;}e[N];stack&lt;int&gt;stk;int head[N],color[N];int tot,cidx,last;int dfn[N],low[N];int max(int a,int b){return a&gt;b?a:b;}int min(int a,int b){return a&lt;b?a:b;} void add(int x,int y){//存图 tot++; e[tot].y=y; e[tot].next=head[x]; head[x]=tot;}void tarjan(int x){ last++;dfn[x]=last;low[x]=last;stk.push(x); for(int i=head[x];i;i=e[i].next){ int y=e[i].y; if(!dfn[y]){ tarjan(y); low[x]=min(low[x],low[y]); }else if(color[y]==0)low[x]=min(low[x],dfn[y]); }if(dfn[x]==low[x]){ ++cidx; while(!stk.empty()){ int t=stk.top();stk.pop(); color[t]=cidx; if(t==x)break; } }}int main(){ scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++){ int a,b; scanf(\"%d%d\",&amp;a,&amp;b); add(a,b); }for(int i=1;i&lt;=n;i++)if(!color[i])tarjan(i); printf(\"%d\\n\",cidx); return 0;} 边双连通分量 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/*g++ -o2 edge_DCC.cpp -o c -std=c++14.\\c*/#include&lt;cstdio&gt;using namespace std;const int N=1e5+100;int max(int a,int b){return a&gt;b?a:b;}int min(int a,int b){return a&lt;b?a:b;}int ops(int x){return x^1;}int head[N];int tot;int dfn[N];int low[N];int color[N];int cidx;int last;int bridge[N];struct node{ int y,next;}e[N];void add(int x,int y){ tot++; e[tot].y=y; e[tot].next=head[x]; head[x]=tot; return ;}void tarjan(int x,int in_edge){ last++; dfn[x]=last; low[x]=last; for(int i=head[x];i;i=e[i].next){ int y=e[i].y; if(!dfn[y]){ tarjan(y,i); low[x]=min(low[x],low[y]); if(dfn[x]&lt;low[y]){ bri[i]=1; bri[ops(i)]=1; } } else if(in_edge!=(i^1))low[x]=min(low[x],dfn[y]); }}void dfs(int x){ color[x]=cidx; for(int i=head[x];i;i=e[i].next){ int y=e[i].y; if(bri[i]||color[y])continue; dfs(y); }}int main(){} 树链剖分及树上操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255/*g++ -o2 sp_xds.cpp -o c -std=c++14.\\c*/ #include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;const int N=1e6+100;const int M=1e3+100;int max(int a,int b){return a&gt;b?a:b;}int min(int a,int b){return a&lt;b?a:b;}int tot;int head[N];struct edge{ int y,w; int next;}e[N];struct node{ int l,r; int pre; int add;}t[N];int ls(int p){return p&lt;&lt;1;}int rs(int p){return p&lt;&lt;1|1;}int ms(int p){return (t[p].l+t[p].r)&gt;&gt;1;}int ops(int p){return p^1;}int dfn[N];int dep[N];int siz[N];int top[N];int fat[N];int son[N];int cod[N];int last;int n,m;int num[N];void swap(int &amp;x,int &amp;y){ int t=x; x=y; y=t; return ;}void add_edge(int x,int y){ e[tot].y=y; e[tot].next=head[x]; head[x]=tot++; return ;}void make_edge(int x,int y){ add_edge(x,y); add_edge(y,x); return ;}void dfs_fir(int x,int fa){ dep[x]=dep[fa]+1; fat[x]=fa; siz[x]=1; int son_max=0; int son_wei=0; for(int i=head[x];~i;i=e[i].next){ int y=e[i].y; if(y==fa)continue; dfs_fir(y,x); siz[x]+=siz[y]; if(siz[y]&gt;son_max){ son_max=siz[y]; son_wei=y; } } son[x]=son_wei; return ;}void dfs_sec(int x,int fa_top){ top[x]=fa_top; dfn[x]=++last; cod[last]=num[x]; if(!son[x])return ; dfs_sec(son[x],fa_top); for(int i=head[x];~i;i=e[i].next){ int y=e[i].y; if(y==fat[x])continue; if(y==son[x])continue; dfs_sec(y,y); } return ;}void push_up(int p){ t[p].pre=t[ls(p)].pre+t[rs(p)].pre; return ;}void push_down(int p){ if(t[p].add){ t[ls(p)].pre+=t[p].add*(t[ls(p)].r-t[ls(p)].l+1); t[rs(p)].pre+=t[p].add*(t[rs(p)].r-t[rs(p)].l+1); t[ls(p)].add+=t[p].add; t[rs(p)].add+=t[p].add; t[p].add=0; }}void build(int p,int l,int r){ t[p].l=l; t[p].r=r; if(l==r){ t[p].pre=cod[l]; return ; } int mid=ms(p); build(ls(p),l,mid); build(rs(p),mid+1,r); push_up(p); return ;}void change_len(int p,int l,int r,int w){ if(l&lt;=t[p].l &amp;&amp; t[p].r&lt;=r){ t[p].pre+=w*(t[p].r-t[p].l+1); t[p].add+=w; return ; } push_down(p); int mid=ms(p); if(l&lt;=mid)change_len(ls(p),l,r,w); if(r&gt; mid)change_len(rs(p),l,r,w); push_up(p); return ;}int ask_len(int p,int l,int r){ // printf(\"start : ask_len ( %lld : %lld , %lld )\\n\",p,l,r); if(l&lt;=t[p].l &amp;&amp; t[p].r&lt;=r)return t[p].pre; push_down(p); int mid=ms(p); int ans=0; if(l&lt;=mid)ans+=ask_len(ls(p),l,r); if(r&gt; mid)ans+=ask_len(rs(p),l,r); // printf(\"end : ask_len\\n\"); return ans;}int lca(int x,int y){ if(dep[x]&lt;dep[y])swap(x,y); while(top[x]!=top[y]){ if(dep[top[x]]&lt;dep[top[y]])swap(x,y); x=fat[top[x]]; } return dep[x]&lt;dep[y]?x:y;}void change_way(int x,int y,int w){ if(dep[x]&lt;dep[y])swap(x,y); while(top[x]!=top[y]){ if(dep[top[x]]&lt;dep[top[y]])swap(x,y); change_len(1,dfn[top[x]],dfn[x],w); x=fat[top[x]]; } if(dep[x]&gt;dep[y])swap(x,y); change_len(1,dfn[x],dfn[y],w); return ;}int ask_way(int x,int y){ // printf(\"start : ask_way\\n\"); if(dep[x]&lt;dep[y])swap(x,y); int ans=0; while(top[x]!=top[y]){ if(dep[top[x]]&lt;dep[top[y]])swap(x,y); ans+=ask_len(1,dfn[top[x]],dfn[x]); x=fat[top[x]]; } if(dep[x]&gt;dep[y])swap(x,y); ans+=ask_len(1,dfn[x],dfn[y]); // printf(\"end : ask_way\\n\"); return ans;}void change_dot_tree(int x,int w){ change_len(1,dfn[x],dfn[x]+siz[x]-1,w); return ;}int ask_dot_tree(int x){ return ask_len(1,dfn[x],dfn[x]+siz[x]-1);}void init(){ memset(head,-1,sizeof(head)); return ;}void debug_build(){ printf(\"\\n\"); printf(\"%lld\\n\",tot); for(int i=0;i&lt;tot;i+=2){ int x=e[ops(i)].y; int y=e[i].y; int w=e[i].w; printf(\"%lld -&gt; %lld : %lld\\n\",x,y,w); } printf(\"\\n\"); return ;}int main(){ // freopen(\"w.txt\",\"r\",stdin); scanf(\"%lld%lld\",&amp;n,&amp;m); init(); for(int i=1;i&lt;=n;i++){ scanf(\"%lld\",&amp;num[i]); } for(int i=1;i&lt;n;i++){ int x,y; scanf(\"%lld%lld\",&amp;x,&amp;y); make_edge(x,y); } dfs_fir(1,0); dfs_sec(1,1); build(1,1,n); for(int i=1;i&lt;=m;i++){ int x,y,w; int op; scanf(\"%lld\",&amp;op); if(op==1){ scanf(\"%lld%lld\",&amp;x,&amp;w); change_way(x,x,w); } if(op==2){ scanf(\"%lld%lld\",&amp;x,&amp;w); change_dot_tree(x,w); } if(op==3){ scanf(\"%lld\",&amp;x); printf(\"%lld\\n\",ask_way(1,x)); } } return 0;}","categories":[{"name":"-模板","slug":"模板","permalink":"http://stairsupon.github.io/categories/%E6%A8%A1%E6%9D%BF/"}],"tags":[]},{"title":"NOIp 2024 游记 & 退役感言","slug":"wordstoOIerslater","date":"2024-12-14T06:38:00.000Z","updated":"2025-01-21T07:28:18.738Z","comments":true,"path":"2024/12/14/wordstoOIerslater/","permalink":"http://stairsupon.github.io/2024/12/14/wordstoOIerslater/","excerpt":"","text":"结束了，一切都结束了。 先浅谈一下这次 NOIP 首先本来这次是抱着很大的希望的，毕竟准备了那么久，还是希望能够拿到比较高的奖项，然而结果却非常令人失望。 DAY 0 考前为了鼓舞士气，我特意做了个主题，现在看来却是讽刺至极。 因为考试当天是星期六，所以在此之前一天我们收拾收拾就回去了，刚好还能不占月假（因为学竞赛，这可能是我们第一次放月假），回到家后想起同学说的长 RP 的好方法 —— 把线段树的模板打一遍，不编译直接提交看能不能一遍过，当时我觉得线段树太简单，决定在此基础上加点难度，于是我直接打树剖模板题，结果当时我想着线段树空间开四倍，一不小心写成了右移四，导致 MLE , 然后改了之后就洗洗睡了，顺带上号把每日任务做了一些（还刷出一个高资）。 DAY 1 考试当天，七点钟已经到达考试地点也就是七中高新，在门口简单吃了一顿早饭，便开始用手机复习一些模板，顺带提交了早就写好的 P4994 终于结束的起点的代码，然后准备入场。 试机 他甚至还有试机时间，这应该是我第一次试机，利用这个时间，我打了一边超级快读和线段树，已备不时之需，此刻我的心里一直鼓励自己，加油。 考试 试题也是发的比较快，还没到点就发下来了，我以自己最快的速度打开试卷，开始读题，当时第一题刚读完，就已经有思路了，简单在草稿纸上推了一下，马上就开始写，也是用了不到 5 min 就写完了，测了一下样例，小样例随便过，而再测大样例的时候就没那么幸运了，结果大了很多，当时我以为是写挂了，于是调了半天（ about 1 hour ），也没调出来当时想着放一放去做下一题。 第二题看上去就很和善，看完之后想到要推式子，但对个人实力不太认可，于是决定骗分（赛后觉得糖丸了，当时还剩三个小时，绝对推得出来），骗分的过程也是相当愉快，很快就骗到 60 分了，大概花了半个小时。 此时，我还剩 2.5 hour 我能干的要么去看后面的题，要么把 T1 切了。一向不擅长选择的我选择了前者（事实证明，如果当时我两个都不选，而是把题全部再读一遍，可能会好很多）。回过头来调 T1 的过程相当痛苦，反复造样例反复算，就是 hack 不了。无奈之下看了一眼 T3 , 结果发现看不了一点，晃了一眼 T4 似乎有点树剖的想法，但想了一想（当时还剩 30 min），还是做 T1 收益最大，当时我已心灰意冷，不知所措，回想自己两年以来的 OI 生涯，感觉懊恼不已。在此刻我选择把题再读一遍，结果却是令人绝望的，我居然把 T1 题面读错了，没有看到相邻两个字，我感觉我已经处于崩溃的边缘，甚至当时不知怎么，我居然笑了出来（现在想起这是多么令人绝望的笑）。 在如此绝望的情形下，我想平时切黄体差不多 10 min ，这题估计也就是个黄题（赛后想了想，抛开证明难度差不多是黄题），然后在心中为自己加油打气，用了 10 min 想外加 10 min 重构（当时全程手都在抖，考完后键盘上全是汗），代码打完后测了一下，居然所有样例一遍过。 最后 5 min 检查了一下，感觉没问题，抱着 160 分的期望成绩，等待着我的 OI 生涯的最后时刻的到来。 而成绩出来之后，却是另一番苦涩，第一题最后用于计数的桶没有清零，导致挂了 70 分，第二题最暴力的点没有换行，导致一分没得，最后一共挂了 130 ，实得 30 分。这是如此的令人绝望。 考后 当天其实我并没有表现过的悲伤，下午还是和同机房的人出去掇了台球，就当是赛后的放松了，顺带还叫上了之前的故友 GGapa。 其实在此刻我已经做好抱零的准备了（虽然没有，但似乎更让我感到悲痛）。 感言 先说寄语 对于后来人，如果你是真心地热爱竞赛，那么不管你是从什么时候开始，希望你能坚持下去；如果你只是为了升学，倘如在你走不下去时，还是尽早放弃为妙。 对于不同时期开始的同学，我认为应该有不同的目标。 保送的名额一年就几十个，谁都不能说自己是稳的，如果你是高中或初三才开始认真学，认清自己，定好目标。也许省一已是最好的归宿。 再说建议 先认清楚你学竞赛的目标，要有长期的规划，什么时候学什么，什么时候练习，什么时候打比赛（强校同学可以无视，一般教练都帮你们规划好了）。 不要摸鱼，这个太重要了，尤其是在做题做到一半时，会打断自己的思路，长期这样还会养成糟糕的思维习惯，导致注意力难以集中，不但影响竞赛，还有文化课。 系统刷题，在学习新算法或练习期间，不要盲目刷题，如果一段时间你在搞数据结构，你就认真地搞，不要因为看到一道别的知识点的好题（或水题），就转移目标，如果真的想做，可以加到做题计划中去，等以后在补。 不要划水，如果一道题，当你选择了要做他时，就一定要把他做出来（只要是在自己能力范围内），这样的题对个人的实力提升是巨大的，因为长时间没有做出来代表了自己的思维盲区，将其消灭，方能取得进步。 赛后改错，这点有多重要我不必多说。如果是想到了正解，但没做出来，建议好好看看自己的代码，找出造成自己漏洞的原因；但如果连正解都没想到，建议好好整理一下思路和过程，最好写一篇题解（可以不发出来，只写给自己看）。不管一道题做没做出来，都建议整理一下结论的证明过程（尤其是贪心和构造这种题目）。 保持谦卑，不要觉得自己实力很强，山外有山，人外有人，每一次我见到新的高手都会刷新我的认知，做好自己，不要因为一次成绩就无法无天，对新的算法，新的 trick 保持一种渴望。 深度挖掘，这个可以说是这几点中最重要的，一个算法，学了之后不但要搞清楚原理，还有模板，扩展以及和其他算法的融合，不要想当然的认为自己会了，便开始学习新的内容。 不留余地，作为一个竞赛生，真的不一定能走出来，但在选择路时不要给自己留余地，不要为了升学才选择 OI，在学的过程中，要学就认真学，耽误 WHK 就耽误，如果连这点代价都承担不了，还有什么必要学 OI 呢？ 以上几点都是结合我的个人经历来的，也是导致我从一个万众瞩目的种子选手到一无是处的废物所没有遵循的，也许这里面有运气和个人的原因，但事实证明，在竞赛这方面，可以说选择大于努力。 最后说一下个人经历 本人于高二遗憾退役（2024.11.30）。 要说初次接触编程，还是在小学四升五的时候，当时我的父母想把我送进当地比较好的学校（下文称为 CW）, 但在面试考试的过程中因为不会表演才艺，遗憾落选。于是我的家长给我报了一个另一个学校（下文称为 SW）的夏令营（主要是搞 WHK 的），而那一周刚好有一节编程课，在此之前我就听说过编程是很高级的东西，上了那节课之后，便对 Python 产生了浓厚的兴趣。 后来一向理科比较好的我进入了当地另一所学校（下文称为 JX）的分校区，再此过程中我也在利用课余时间学习 Python, 在后来的一场由 CW 举办的比赛中（更竞赛题比起来，全是入机题）拿到了比较好的成绩，然后就被机构推荐去学习 C++。 自此，我苦涩如歌的 OI 生涯开始了。 小学第一次参考 CSP-J，不出意外初赛只拿了 30 分。因为当时那个机构的课程已经学完（其实就是把 C++ 的语法基础学完了），所以打算换一个机构。 后来我的家长选择了学而思网课的 C++ 课程，而事实证明这无疑是一个错误的选择。一周两个小时的听课时间，十分钟的刷题量，学了一年也没有什么起色。后来小升初，因为强制要求大摇号，导致不敢去摇知名的学校（虽然我的成绩是可以考上的），只能选择一个才开两年且承诺非常好的学校（下文称 DC），然而这才是最错误的选择。 在临近我初一 CSP-J 时，我的家长将我送到了当地的科普基地进行学习，","categories":[{"name":"闲话","slug":"闲话","permalink":"http://stairsupon.github.io/categories/%E9%97%B2%E8%AF%9D/"}],"tags":[{"name":"鲜花","slug":"鲜花","permalink":"http://stairsupon.github.io/tags/%E9%B2%9C%E8%8A%B1/"},{"name":"感言","slug":"感言","permalink":"http://stairsupon.github.io/tags/%E6%84%9F%E8%A8%80/"}]},{"title":"题解：P11243 繁花","slug":"P11243flowers","date":"2024-11-05T11:44:00.000Z","updated":"2025-01-21T06:55:56.913Z","comments":true,"path":"2024/11/05/P11243flowers/","permalink":"http://stairsupon.github.io/2024/11/05/P11243flowers/","excerpt":"","text":"这是一篇图论做法题解 闲话：我看到基本上都是动态规划做法，但我考场上第一时间想到了图论，并且个人认为图论做法更好想到一些，故写此题解。 思路 首先，容易知道对于一个点的贡献，可以认为是一定比该点小的点的个数，而在这里很容易想到可以从该点连边到比该直接点小的点（即题目描述中直接用 或 连接的点），而题目描述中出现若干的点值可能相等，我们可以将这些点合并为一个点并统计相同的个数，然后整体来乘比该点小的点的个数，这样可以用 的复杂度过掉此题。 方便理解，这里给出样例中最后一个的图。 具体实现 先根据题中给的大小关系建图，从大的点向小的连边，相等则合并（我用的是并查集，其实也可以用缩点），然后统计子树大小总和，该点的贡献即为该点的数量乘上子树大小总和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156/*g++ -o2 2.cpp -o c -std=c++14./c*/#include&lt;cstdio&gt;using namespace std;typedef long long ll;const int N=5e6+100;const int M=5e6+100;char *p1,*p2;char buf[100];#define nc() getchar()// #define nc() (p1==p2 &amp;&amp; (p2=(p1=buf)+fread(buf,1,100,stdin),p1==p2)?EOF:*p1++)inline void read(int &amp;x){ x=0; char ch=nc(); while(ch&lt;48 || ch&gt;57){ ch=nc(); } while(ch&gt;=48 &amp;&amp; ch&lt;=57){ x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-48; ch=nc(); } return ;}int tot;int head[N];struct edge{ int x; int y; int next;}e[M];int T;int n,m;int siz[N];int cnt[N];int son[N];int fa[N];int in[N];char s[N];int vis[N];ll ans;inline void init(){ tot=0; for(int i=1;i&lt;=n+10;i++){ siz[i]=0; cnt[i]=1; head[i]=-1; fa[i]=i; vis[i]=0; } return ;}inline void add(int x,int y){ e[tot].x=x; e[tot].y=y; e[tot].next=head[x]; head[x]=tot++; return ;}inline int find(int x){ while(fa[x]^x) x=fa[x]; return x;}inline void merge(int x,int y){ int a=find(x); int b=find(y); if(a!=b){ fa[b]=a; cnt[a]+=cnt[b]; cnt[b]=0; } return ;}void dfs(int x,int fa){ siz[x]=cnt[x]; for(int i=head[x];~i;i=e[i].next){ int y=e[i].y; if(y==fa)continue; if(!vis[y])dfs(y,x); siz[x]+=siz[y]; } if(!vis[x]){ ans+=ll(cnt[x]*(siz[x]-cnt[x])); vis[x]=1; } return ;}void debug_build(){ printf(\"\\n\"); printf(\"%d\\n\",tot); for(int i=0;i&lt;tot;i++){ int x=e[i].x; int y=e[i].y; // int w=e[i].w; printf(\"%d %d\\n\",x,y); } printf(\"\\n\"); return ;}int main(){ read(T); while(T--){ ans=0; read(n); init(); scanf(\"%s\",s); for(int i=1;i&lt;n;i++){ if(s[i-1]=='='){ merge(i,i+1); vis[i+1]=1; } } for(int i=1;i&lt;n;i++){ int x=find(i); int y=find(i+1); if(s[i-1]=='&lt;')add(y,x); else if(s[i-1]=='&gt;')add(x,y); } // debug_build(); for(int i=1;i&lt;=n;i++){ printf(\"%d %d \\n\",i,fa[i]); } for(int i=1;i&lt;=n;i++){ if(!vis[i])dfs(i,0); } printf(\"%lld\\n\",ans); } return 0;}/*113=&gt;&lt;&lt;=&lt;=&gt;=&gt;&lt;&gt;*/","categories":[{"name":"题解","slug":"题解","permalink":"http://stairsupon.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://stairsupon.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"凸轮","slug":"凸轮","permalink":"http://stairsupon.github.io/tags/%E5%87%B8%E8%BD%AE/"}]},{"title":"题解：P10940 舞动的夜晚","slug":"P10940swingnight","date":"2024-10-09T12:49:00.000Z","updated":"2025-01-21T07:40:02.962Z","comments":true,"path":"2024/10/09/P10940swingnight/","permalink":"http://stairsupon.github.io/2024/10/09/P10940swingnight/","excerpt":"","text":"闲话 基于本题没有题解，那我来水一发网络流，先声明一下，本篇题解可能有部分口胡现象（本人太菜不会证明，但结论是对的，感性理解一下）。 正文 本题的结果不能直接用网络流跑出来（至少我不能）。网络流的题重在建图，但这题不一样，他更多是在考察对残余网络的操作。 首先我们看这个东西和二分图匹配有点像所以先把图拆点然后画出来，如下。 显然这个图的最大流（最大匹配）是 ，即最多能选出三对组队的人，而选用后会对最大流造成影响的边是 。因为选了这几条边后会直接或间接占用其他的流量通道，所以在这个图中答案显然是上述几条边，但如果我们看下面这个图。 能删去的边就不是那三条了，而只有 ，两条，相比之下 这条边就不会造成影响了，因为 点可以通过选择 点原来必须经过的点，即可以走 这条边。 然后我们发现可以将所有的便分为三种： 必行边：要保证最大流不变的情况下必须流过的边。 可行边：要保证最大流不变情况下有选择余地的边，即要在若干条边中选择一条边作为要流过的边。 不行边：要保证最大流不变情况下不能有流量流过的边。 那么可以发现，在第一个图中， ,都是必行边，而其他三条都为不行边，而第二个图中，只有 是必行边，而 ,都是可行边。 对于任意一条用于匹配的边，经过观察可以发现（下文的强连通分量指在残余网络中求得的结果，即求强连通分量的算法在运行时只能跑有流量的边）： 若该边流量为一，且该边的两个点不位于一个强连通分量，该边为必行边。 若该边的两点位于同一强连通分量中，且该强连通分量中存在一条从左点指向右点的边，即该强连通分量中有已经匹配成功的点，该边为可行边。 若该边流量为零且两点并不位于同一强连通分量，该边为不行边。 接下来讲一下为什么可行边的定义如上，先看图。 首先图中四个点位于一个强连通分量（网络流要求双向建边），我们由强连通分量的定义，这四个点最后会位于一个可以互相到达的环中，而因为这个性质，在这个环中，最大流相当于选择若干条边刚好将整个环的点覆盖，是可以自由选择的。 可行边理解了，必行边和不行边的定义应该也明白了。 那整道题的思路也清晰了，在原二分图中跑最大流，然后在有流量的边上跑强连通分量，最后判定不行边。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219/*g++ -o2 P10940.cpp -o c -std=c++14.\\c*/#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int N=2e4+100;const int M=4e5+100;const int inf=0x3f3f3f3f;char *p1,*p2;char buf[100];// #define nc() getchar()#define nc() (p1==p2 &amp;&amp; (p2=(p1=buf)+fread(buf,1,100,stdin),p1==p2)?EOF:*p1++)inline void read(int &amp;x){ x=0; char ch=nc(); while(ch&lt;48 || ch&gt;57){ ch=nc(); } while(ch&gt;=48 &amp;&amp; ch&lt;=57){ x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-48; ch=nc(); } return ;}int tot;int head[N];struct edge{ // int x; int y; int f; int next;}e[M];int dep[N];int gap[N];int cur[N];int last;int dfn[N];int low[N];int cidx;int col[N];int nl,nr;int n,m;int s,t;int bri_sta;int top;int pri[N];int q[M];int stk[M];int _top;inline int max(int a,int b){return a&gt;b?a:b;}inline int min(int a,int b){return a&lt;b?a:b;}inline int ops(int x){return x^1;}void init(){ tot=0; memset(head,-1,sizeof(head)); s=0; t=nl+nr+1; return ;}inline void add(int x,int y,int f){ e[tot].y=y; e[tot].f=f; e[tot].next=head[x]; head[x]=tot++; return ;}inline void make(int x,int y,int f){ add(x,y,f); add(y,x,0); return ;}void debug(){ for(int i=0;i&lt;tot;i+=2){ int x=e[ops(i)].y; int y=e[i].y; int f=e[i].f; printf(\"%d %d %d \\n\",x,y,f); } return ;}void bfs(int start,int to){ memset(dep,-1,sizeof(dep)); int hh=0; int tt=1; q[hh]=to; dep[to]=0; gap[0]=1; while(hh!=tt){ int x=q[hh++]; if(hh==M)hh=0; for(int i=head[x];~i;i=e[i].next){ int y=e[i].y; if(dep[y]!=-1)continue; dep[y]=dep[x]+1; gap[dep[y]]++; q[tt++]=y; if(tt==M)tt=0; } } return ;}int find(int x,int to,int lim){ if(x==to)return lim; int flow=0; for(int i=cur[x];~i;i=e[i].next){ int y=e[i].y; int f=e[i].f; cur[x]=i; if(!f)continue; if(dep[y]+1==dep[x]){ int t=find(y,to,min(f,lim-flow)); if(t&gt;0){ e[i].f-=t; e[ops(i)].f+=t; flow+=t; } if(flow==lim)return flow; } } gap[dep[x]]--; if(!gap[dep[x]])dep[s]=n+1; dep[x]++; gap[dep[x]]++; return flow;}int ISAP(int start,int to){ int flow=0; bfs(start,to); while(dep[start]&lt;=n+1){ memcpy(cur,head,sizeof(head)); // for(int i=1;i&lt;=n+1000;i++)cur[i]=head[i]; flow+=find(start,to,inf); } return flow;}void tarjan(int x){ last++; dfn[x]=last; low[x]=last; stk[++_top]=x; for(int i=head[x];~i;i=e[i].next){ if(!e[i].f)continue; int y=e[i].y; if(!dfn[y]){ tarjan(y); low[x]=min(low[x],low[y]); } else if(!col[y])low[x]=min(low[x],dfn[y]); } if(dfn[x]==low[x]){ cidx++; while(_top){ int t=stk[_top--]; col[t]=cidx; if(t==x)break; } } return ;}int main(){ read(nl); read(nr); read(m); n=nl+nr+2; init(); for(int i=1;i&lt;=nl;i++)make(s,i,1); for(int i=1;i&lt;=nr;i++)make(i+nl,t,1); bri_sta=tot; for(int i=1;i&lt;=m;i++){ int x,y; read(x); read(y); y+=nl; make(x,y,1); } // debug(); // printf(\"%d\\n\",ISAP(s,t)); int ans=ISAP(s,t); for(int i=1;i&lt;=n;i++)if(!dfn[i])tarjan(i); for(int i=bri_sta;i&lt;tot;i+=2){ int x=e[ops(i)].y; int y=e[i].y; int f=e[i].f; if(f &amp;&amp; col[x]!=col[y]){ pri[++top]=(i-bri_sta)/2+1; } } printf(\"%d\\n\",top); for(int i=1;i&lt;=top;i++){ printf(\"%d \",pri[i]); } putchar('\\n'); return 0;}","categories":[{"name":"网络流","slug":"网络流","permalink":"http://stairsupon.github.io/categories/%E7%BD%91%E7%BB%9C%E6%B5%81/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://stairsupon.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"图论建模","slug":"图论建模","permalink":"http://stairsupon.github.io/tags/%E5%9B%BE%E8%AE%BA%E5%BB%BA%E6%A8%A1/"}]},{"title":"P10938 Vani和Cl2捉迷藏","slug":"P10938Vanicl","date":"2024-09-16T11:44:00.000Z","updated":"2025-01-21T07:49:44.433Z","comments":true,"path":"2024/09/16/P10938Vanicl/","permalink":"http://stairsupon.github.io/2024/09/16/P10938Vanicl/","excerpt":"","text":"闲话 基于本题已经有人写了匈牙利的题解，这里我就来写一篇关于网络流的题解。 能做这道题的人应该都能看出是裸的最小重复路径覆盖问题吧。 虽然最小路径覆盖原代码只会红一个点。 思路 首先网络流的难点一直都是在于建图，那么这道题该怎么建图呢？ 引入 先想一下普通的最小路径覆盖集问题，我们的见图方式是将每个点拆为出点和入点，目的是保证每个点刚好只被所有路径经过一次。 然后将源点和入点连接，汇点和出点连接（废话）。 对于原图中的连边 我们将 出点连接到 入点。 仔细考虑一下为什么这么建图，我的解释是这样的：对于最小路径覆盖我们肯定希望能用最少的路径覆盖不重不漏覆盖所有点，那么上面这种建图方式，可以再实际运行中像穿针引线一样把所有这条路径上是点用 的单位流量穿起来从起点引导到终点，而因为过程中限流，所以就算有多条边和改点相连，最后也只会穿到一条路径上，而跑满最大流的过程最好就是将上面所有的边 都跑上一的流量，刚好满足最大流的性质。 正解 最小路径覆盖和最小重复路径覆盖的区别在于，后者可以是一条边被多次覆盖，那该怎么办呢？ 其实唯一区别就是将原来的建边改为将一个点和它所有能沿着当前边能到达的点都连上有向边。 现在考虑为什么？ 因为是重复覆盖，因此可以有多条路径同起点或同终点，而原来一条路径可能会被另一条分成两条，而现在可以直接用两点表示一整条路径，故上述建图方式可行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187/*g++ -o2 P10938.cpp -o c -std=c++14.\\c*/#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;using namespace std;const int N=4e2+20;const int M=5e4+100;const int inf=0x3f3f3f3f;inline int max(int a,int b){return a&gt;b?a:b;}inline int min(int a,int b){return a&lt;b?a:b;}inline int ops(int x){return x^1;}int tot;int head[N];struct edge{ int y,f,w; int next;}e[M];int cur[N];int dep[N];int q[M];int in[N];int ou[N];int n,m;int s,t;int con[N][N];vector&lt;int&gt;v[N];char *p1,*p2;char buf[10];// #define nc getchar#define nc() (p1==p1 &amp;&amp; (p2=(p1=buf)+fread(buf,1,10,stdin),p1==p2)?EOF:*p1++)inline void read(int &amp;x){ int sum=0; char ch=nc(); while(ch&lt;48 || ch&gt;57){ ch=nc(); } while(ch&gt;=48 &amp;&amp; ch&lt;=57){ sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-48; ch=nc(); } x=sum; return ;}inline void add(int x,int y,int f){ e[tot].y=y; e[tot].f=f; e[tot].next=head[x]; head[x]=tot++; return ;}inline void make(int x,int y,int f){ add(x,y,f); add(y,x,0); return ;}inline bool bfs(int start,int to){ int hh=0; int tt=1; memset(dep,-1,sizeof(dep)); // for(int i=1;i&lt;=n*2+10;i++)dep[i]=-1; q[hh]=start; cur[start]=head[start]; dep[start]=0; while(hh!=tt){ int x=q[hh++]; if(tt==M)hh=0; for(int i=head[x];~i;i=e[i].next){ int y=e[i].y; int f=e[i].f; if(!f)continue; if(dep[y]==-1){ dep[y]=dep[x]+1; cur[y]=head[y]; if(y==to)return true; q[tt++]=y; if(tt==M)tt=0; } } } return false;}inline int find(int x,int to,int limit){ if(x==to)return limit; int flow=0; for(int i=cur[x];~i &amp;&amp; flow&lt;limit;i=e[i].next){ int y=e[i].y; int f=e[i].f; cur[x]=i; if(!f)continue; if(dep[y]==dep[x]+1){ int t=find(y,to,min(limit-flow,f)); if(!t)dep[y]=-1; e[i].f-=t; e[ops(i)].f+=t; flow+=t; } } return flow;}inline void dinic(int start,int to,int &amp;ans){ int flow=0; int r=0; while(bfs(start,to)){ while(flow=find(start,to,inf)){ r+=flow; } } ans=r; return ;}inline void init(){ tot=0; memset(head,-1,sizeof(head)); s=0; t=n*2+1; return ;}inline void debug_build(){ for(int i=0;i&lt;tot;i+=2){ int x=e[ops(i)].y; // int x=e[i].x; int y=e[i].y; int f=e[i].f; // int w=e[i].w; printf(\"%d -&gt; %d :%d\\n\",x,y,f); } return ;}inline void dfs(int x,int fro){ for(int i=0;i&lt;v[x].size();i++){ int y=v[x][i]; if(con[fro][y])continue; con[fro][y]=1; // con[y][fro]=1; dfs(y,fro); } return ;}int main(){ scanf(\"%d%d\",&amp;n,&amp;m); init(); for(int i=1;i&lt;=m;i++){ int x,y; scanf(\"%d%d\",&amp;x,&amp;y); v[x].push_back(y); } for(int i=1;i&lt;=n;i++){ dfs(i,i); for(int j=1;j&lt;=n;j++){ if(con[i][j]){ make(i+n,j,1); } } } for(int i=1;i&lt;=n;i++){ make(s,i+n,1); make(i,t,1); } int ans; // debug_build(); dinic(s,t,ans); printf(\"%d\\n\",n-ans); return 0;} 最后祝喜欢瓦尼瓦尼的 能早日水神满命。","categories":[{"name":"网络流","slug":"网络流","permalink":"http://stairsupon.github.io/categories/%E7%BD%91%E7%BB%9C%E6%B5%81/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://stairsupon.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"图论建模","slug":"图论建模","permalink":"http://stairsupon.github.io/tags/%E5%9B%BE%E8%AE%BA%E5%BB%BA%E6%A8%A1/"}]},{"title":"题解：P11021 「LAOI-6」区间测速","slug":"P11021speedtest","date":"2024-09-08T05:10:00.000Z","updated":"2025-01-21T08:00:25.009Z","comments":true,"path":"2024/09/08/P11021speedtest/","permalink":"http://stairsupon.github.io/2024/09/08/P11021speedtest/","excerpt":"","text":"题意简化 每次修改一个点的横坐标，求斜率最大值 如何思考 首先考虑，如果没有修改操作，只是单纯的问你任意两点之间的斜率，该怎么办？ 暴力 这里有一个 的做法是任意点都算一遍求最大斜率但显然不可能。 优化 其实学过斜率优化的都知道可以先以横坐标为关键词排个序（可以理解为在坐标轴上画出来），然后要求的任意两点的斜率最大值就是是排序后相邻两点的斜率的最大值。 那没学过怎么办，这里来证明： 对于上面这张图，我们将要处理的点在坐标轴上描出来（在程序里体现为排序），显然直线 的斜率最大，在程序内部点都已经排好序，当处理到点 时发现前一个点和当前点的斜率大于当前已知的最大斜率，即 于是将当前的最大值更改。 接下来是疑点，为啥最大斜率一定是相邻两点的，图中可以看出 ，我们假设有三个点 那可以得出 ,。 通过计算可以得到若 , 就一定会有 。 所以得出以上结论。 该怎么用 其实加上修改之后我们发现每次修改真正影响到的只有两个点即前面的点和后面的点，于是我们可以预处理出不修改时的最大斜率，再每次和修改后的点产生的贡献（即修改后位置前后的斜率）对比取最大值，求解。 但有一个问题如果修改影响到最大值怎么办，其实只需要再处理出次大值就可以了。 注意不是直接求次大值，是要求和最大值没有公共点的次大值 最后判断一下即可，注意要判断修改到最前面和最后面的情况。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/*g++ -o2 3.cpp -o c -std=c++14.\\c*/#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;const int N=5e5+100;int n,m;int max(int a,int b){return a&gt;b?a:b;}int min(int a,int b){return a&lt;b?a:b;}int abs(int a){return a&gt;0?a:-a;}struct node{ int x,t; int id; bool operator &lt; (const node s){ if(t!=s.t)return t &lt; s.t; return x &lt; s.x; }}e[N];int max_fir;int max_sec;int fro_fir;int fro_sec;int tim[N];int find(int t){ int l=1; int r=n; if(t&lt;e[1].t)return 0; if(t&gt;e[n].t)return n+1; while(l&lt;r){ int mid=(l+r)&gt;&gt;1; if(e[mid].t&gt;=t)r=mid; else l=mid+1; } return l;}int main(){ scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++){ scanf(\"%d%d\",&amp;e[i].x,&amp;e[i].t); tim[i]=e[i].t; } sort(e+1,e+n+1); for(int i=2;i&lt;=n;i++){ // int w= int d=abs(e[i].x-e[i-1].x)/abs(e[i].t-e[i-1].t); if(d&gt;max_fir){ if(fro_fir!=i-1){ max_sec=max_fir; fro_sec=fro_fir; } max_fir=d; fro_fir=i; } else if(d&gt;max_sec){ if(fro_fir!=i-1){ max_sec=d; fro_sec=i; } } } // return 0; int ans; for(int i=1;i&lt;=m;i++){ int u,v; ans=0; scanf(\"%d%d\",&amp;u,&amp;v); u=tim[u]; // printf(\"%d\\n\",u); int d=find(u); int tmp=find(v); int tx=e[d].x; // if(v==e[tmp].t)tmp++; int d1=0; int d2=0; if(tmp==0){ int www=abs(v-e[tmp].t); if(www==0)d2=0; else d2=abs(tx-e[tmp].x)/www; } else if(tmp==n+1){ int www=abs(v-e[tmp-1].t); if(www==0)d2=0; else d1=abs(tx-e[tmp-1].x)/www; // printf(\"d1: %d\\n\",d1); } else { int www=abs(v-e[tmp].t); if(www==0)d2=0; else d2=abs(tx-e[tmp].x)/abs(v-e[tmp].t); www=abs(v-e[tmp-1].t); if(www==0)d2=0; else d1=abs(tx-e[tmp-1].x)/www; } ans=max(d1,d2); // printf(\"%d %d\\n\",d,fro_fir); if(d!=fro_fir &amp;&amp; d!=fro_fir-1){ ans=max(ans,max_fir); } else { ans=max(ans,max_sec); } // printf(\"%d\\n\",d); // printf(\"%d\\n\",tmp); printf(\"%d\\n\",ans); } // for(int i=1;i&lt;=n;i++){ // printf(\"%d %d \\n\",e[i].t,e[i].x); // } return 0;}","categories":[{"name":"-二分","slug":"二分","permalink":"http://stairsupon.github.io/categories/%E4%BA%8C%E5%88%86/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://stairsupon.github.io/tags/%E4%BA%8C%E5%88%86/"},{"name":"贪心","slug":"贪心","permalink":"http://stairsupon.github.io/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"P9384 [THUPC 2023 决赛] 着色","slug":"P9384color","date":"2024-08-10T00:16:00.000Z","updated":"2025-01-21T09:40:16.034Z","comments":true,"path":"2024/08/10/P9384color/","permalink":"http://stairsupon.github.io/2024/08/10/P9384color/","excerpt":"","text":"P9384 构造题，首先考虑爆搜，但结果跑不出来。 既然题目中描述相同元素不能构成三元环或五元环，其实可以把条件用的更局限，考虑相同元素只能构成偶环，即同一权值的边构成二分图，可以发现本题刚好 种颜色，刚好 。 接下来考虑怎么构造二分图，本题大部分思路都是令 ，并将 作为染色的依据，但没有提到怎么去想出这样的思路。 首先，令一个集合 ，其中的元素互不相同,且都不为零。 令另一个集合 ，其中 且 满足 ，特别地 。 说人话就是集合 是由集合 中两个相邻的元素异或得到的。 对于以上两个集合有一个性质：即当 为偶数时，对于形式类似于 的情况刚好能不重不漏的覆盖整个 集合，具体请读者自证。 那以上结论有什么用呢？可以发现在一个二分图里面，点数刚好是偶数，而每个点的序都不同，刚好满足上述条件，故可以按照思路中的 作为染色的依据。 123456789101112131415161718192021222324252627282930/*g++ -o2 P9384.cpp -o c -std=c++14.\\c*/#include&lt;cstdio&gt;using namespace std;const int N=1e3+100;int n;int t[N];int lowbit(int x){ return x&amp;(-x);}int main(){ scanf(\"%d\",&amp;n); for(int i=0;i&lt;=10;i++){ t[1&lt;&lt;i]=i; } for(int i=1;i&lt;n;i++){ for(int j=i+1;j&lt;=n;j++){ printf(\"%d\",t[lowbit(i^j)]); } printf(\"\\n\"); } return 0;}","categories":[],"tags":[{"name":"构造","slug":"构造","permalink":"http://stairsupon.github.io/tags/%E6%9E%84%E9%80%A0/"}]},{"title":"网络流模板","slug":"wll-mb","date":"2024-02-29T06:45:00.000Z","updated":"2025-01-22T00:25:51.933Z","comments":true,"path":"2024/02/29/wll-mb/","permalink":"http://stairsupon.github.io/2024/02/29/wll-mb/","excerpt":"","text":"最大流_dinic EK算法 由于最大流中一定没有增广路由于最大流中一定没有增广路 可以不断从源点出发寻找增广路可以不断从源点出发寻找增广路 并在残余网络上修改并在残余网络上修改 直到不存在增广路为止 dinic 由于EK每次只能搜索1条增广路 在EK算法的基础上,建立分层图,并搜索多条增广路 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/*g++ -o2 w.cpp -o c -std=c++14.\\c*/bool bfs(ll start,ll to){ ll fron=0; ll back=1; memset(dep,-1,sizeof(dep)); q[fron]=start; cur[start]=head[start];//弧优化 dep[start]=0; while(fron!=back){ ll x=q[fron++]; if(fron==N)fron=0; for(ll i=head[x];~i;i=e[i].next){ ll y=e[i].y; ll f=e[i].f; ll w=e[i].w; if(dep[y]==-1 &amp;&amp; f){ dep[y]=dep[x]+1; cur[y]=head[y];//记录弧 if(y==to)return true; q[back++]=y; if(back==N)back=0; } } } return false;}ll find(ll x,ll to,ll limit){ if(x==to)return limit; ll flow=0; for(ll i=cur[x];~i &amp;&amp; flow&lt;limit;i=e[i].next){ ll y=e[i].y; ll f=e[i].f; ll w=e[i].w; cur[x]=i; if(dep[y]==dep[x]+1 &amp;&amp; f){ //如果不是相邻的层就不继续 //当权值不大于零时，不符合流限制 ll t=find(y,to,min(limit-flow,f)); if(!t)dep[y]=-1;//废点优化 e[i].f-=t; e[ops(i)].f+=t; flow+=t; } } return flow;}ll dinic(ll start,ll to){ ll flow; ll r=0; //先找增广路径 //再深搜求该路径最大可行流 while(bfs(start,to)) while(flow=find(start,to,inf)) r+=flow; return r;} ISAP 在 的基础上在进行优化,优化掉了多次寻找增广路的过程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960inline bool bfs(int start,int to){ int fron=0; int back=1; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); q[fron]=to; dep[to]=0; gap[0]=1; while(fron!=back){ int x=q[fron++]; if(fron==N)fron=0; for(int i=head[x];~i;i=e[i].next){ int y=e[i].y; int f=e[i].f; if(dep[y]==-1){ dep[y]=dep[x]+1; gap[dep[y]]++; q[back++]=y; if(back==N)back=0; } } } return false;}inline ll find(int x,int to,ll limit){ if(x==to)return limit; ll flow=0; for(int i=cur[x];~i;i=e[i].next){ int y=e[i].y; int f=e[i].f; cur[x]=i; if(!f)continue; if(dep[y]+1==dep[x]){ ll t=find(y,to,min(limit-flow,f)); if(t&gt;0){ e[i].f-=t; e[ops(i)].f+=t; flow+=t; } if(flow==limit)return flow; } } gap[dep[x]]--; if(!gap[dep[x]])dep[s]=n+1; dep[x]++; gap[dep[x]]++; return flow;}inline ll ISAP(int start,int to){ ll flow=0; bfs(start,to); while(dep[s]&lt;n){ memcpy(cur,head,sizeof(head)); flow+=find(start,to,inf); } return flow;} 无源汇上下界可行流 123456789101112131415161718192021222324252627282930313233int main(){ scanf(\"%d%d\",&amp;n,&amp;m); init(); for(int i=1;i&lt;=m;i++){ int x,y,c,w; scanf(\"%d%d%d%d\",&amp;x,&amp;y,&amp;c,&amp;w); make(x,y,c,w); erz[x]-=c; erz[y]+=c; } for(int i=1;i&lt;=n;i++){ if(erz[i]&gt;0){ make(s,i,0,erz[i]); sum+=erz[i]; } if(erz[i]&lt;0)make(i,t,0,-erz[i]); } int ans=dinic(s,t); // printf(\"%d \\n%d \\n\",ans,sum); if(ans==sum){ printf(\"YES\\n\"); for(int i=0;i&lt;m*2;i+=2){ int w=e[ops(i)].w; int l=e[i].v; printf(\"%d\\n\",w+l); } } else printf(\"NO\"); return 0;} 有源汇上下界最大流 123456789101112131415161718192021222324252627282930int main(){ scanf(\"%d%d%d%d\",&amp;n,&amp;m,&amp;s,&amp;t); init(); for(int i=1;i&lt;=m;i++){ int x,y,c,w; scanf(\"%d%d%d%d\",&amp;x,&amp;y,&amp;c,&amp;w); erz[x]-=c;erz[y]+=c; make(x,y,c,w); } for(int i=1;i&lt;=n;i++){ if(erz[i]&gt;0){ make(S,i,0,erz[i]); sum+=erz[i]; } if(erz[i]&lt;0)make(i,T,0,-erz[i]); } make(t,s,0,inf); int cnt=dinic(S,T); if(cnt&lt;sum){ printf(\"No Solution\\n\"); return 0; } int res=e[tot-1].w; e[tot-1].w=0; e[tot-2].w=0; int ans=dinic(s,t); printf(\"%d\\n\",res+ans); return 0;} 有源汇上下界最小流 1234567891011121314151617181920212223242526272829int main(){ scanf(\"%d%d%d%d\",&amp;n,&amp;m,&amp;s,&amp;t); init(); for(int i=1;i&lt;=m;i++){ int x,y,c,w; scanf(\"%d%d%d%d\",&amp;x,&amp;y,&amp;c,&amp;w); erz[x]-=c;erz[y]+=c; make(x,y,c,w); } for(int i=1;i&lt;=n;i++){ if(erz[i]&gt;0){ make(S,i,0,erz[i]); sum+=erz[i]; } if(erz[i]&lt;0)make(i,T,0,-erz[i]); } make(t,s,0,inf); int cnt=dinic(S,T); if(cnt&lt;sum){ printf(\"No Solution\\n\"); return 0; } int res=e[tot-1].w; e[tot-1].w=0; e[tot-2].w=0; int ans=dinic(t,s); printf(\"%d\\n\",res-ans); return 0;} 费用流 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/*g++ -o2 2174.cpp -o c -std=c++14.\\c*/#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int N=1e6+100;const int M=1e3+100;const int inf=0x3f3f3f3f;int max(int a,int b){return a&gt;b?a:b;}int min(int a,int b){return a&lt;b?a:b;}int ops(int x){return x^1;}int tot;int head[N];struct node{ int y,w,f,next;}e[N];int pre[N];int dis[N];int flo[N];int vis[N];int q[N];int n,m,s,t;void add(int x,int y,int f,int w){ e[tot].y=y; e[tot].f=f; e[tot].w=w; e[tot].next=head[x]; head[x]=tot++; return ;}void make(int x,int y,int f,int w){ add(x,y,f,w); add(y,x,0,-w); return ;}bool spfa(int start,int to){ int fron=0; int back=1; memset(dis,0x3f,sizeof(dis)); memset(flo,0,sizeof(flo)); q[fron]=start; dis[start]=0; flo[start]=inf; while(fron!=back){ int x=q[fron++]; if(fron==N)fron=0; vis[x]=0; // printf(\"%d\\n\",x); for(int i=head[x];~i;i=e[i].next){ int y=e[i].y; int w=e[i].w; int f=e[i].f; if(f &amp;&amp; dis[y]&gt;dis[x]+w){ flo[y]=min(flo[x],f); dis[y]=dis[x]+w; pre[y]=i; if(!vis[y]){ q[back++]=y; if(back==N)back=0; vis[y]=true; } } } } return flo[to]&gt;0;}void EK(int &amp;flow,int &amp;cost,int start,int to){ flow=0; cost=0; while(spfa(start,to)){ int t=flo[to]; flow+=t; cost+=t*dis[to]; for(int i=to;i!=start;i=e[ops(pre[i])].y){ e[pre[i]].f-=t; e[ops(pre[i])].f+=t; } } return ;}void init(){ memset(head,-1,sizeof(head)); return ;}int main(){ scanf(\"%d%d%d%d\",&amp;n,&amp;m,&amp;s,&amp;t); init(); for(int i=1;i&lt;=m;i++){ int x,y,w,f; scanf(\"%d%d%d%d\",&amp;x,&amp;y,&amp;f,&amp;w); make(x,y,f,w); } // printf(\"%d\\n\",tot); int flow; int cost; EK(flow,cost,s,t); printf(\"%d %d\\n\",flow,cost); return 0;} Primal-Dual 原始对偶算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161/*g++ -o2 dij_fei.cpp -o c -std=c++14.\\c*/#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;// #include&lt;vector&gt;using namespace std;const int N=5e3+100;const int M=1e6+100;const int inf=0x3f3f3f3f;int tot;int head[N];struct edge{ // int x; int y; int f,w; int next;}e[M];struct node{ int x,w; bool operator &lt;(const node &amp;s)const{ return w &gt; s.w; }};int cnt[N];int tmp[N];int vis[N];int pre[N];int dis[N];int flo[N];int n,m;int s,t;inline int max(int a,int b){return a&gt;b?a:b;}inline int min(int a,int b){return a&lt;b?a:b;}inline int ops(int x){return x^1;}inline void init(){ tot=0; memset(head,-1,sizeof(head)); return ;}inline void add(int x,int y,int f,int w){ e[tot].y=y; e[tot].f=f; e[tot].w=w; e[tot].next=head[x]; head[x]=tot++;}inline void make(int x,int y,int f,int w){ add(x,y,f,w); add(y,x,0,-w); return ;}inline void spfa(int start,int to){ memset(tmp,0x3f,sizeof(tmp)); queue&lt;int&gt;q; q.push(start); tmp[start]=0; while(!q.empty()){ int x=q.front(); q.pop(); vis[x]=0; for(int i=head[x];~i;i=e[i].next){ int y=e[i].y; int f=e[i].f; int w=e[i].w; if(!f)continue; if(tmp[x]+w&lt;tmp[y]){ tmp[y]=tmp[x]+w; if(!vis[y]){ vis[y]=1; q.push(y); } } } } return ;}inline bool dij(int start,int to){ priority_queue&lt;node&gt;q; for(int i=1;i&lt;=n;i++){ dis[i]=inf; flo[i]=0; vis[i]=0; } dis[start]=0; flo[start]=inf; q.push(node{start,dis[start]}); while(!q.empty()){ int x=q.top().x; q.pop(); if(vis[x])continue; vis[x]=1; for(int i=head[x];~i;i=e[i].next){ int y=e[i].y; int f=e[i].f; int w=e[i].w+tmp[x]-tmp[y]; if(!f)continue; if(dis[y]&gt;dis[x]+w){ flo[y]=min(flo[x],f); dis[y]=dis[x]+w; pre[y]=i; q.push(node{y,dis[y]}); } } } return flo[to]&gt;0;}inline void EK(int start,int to,int &amp;flow,int &amp;cost){ flow=0; cost=0; while(dij(start,to)){ int t=flo[to]; flow+=t; cost+=t*(dis[to]-tmp[start]+tmp[to]); for(int i=to;i!=start;i=e[ops(pre[i])].y){ e[pre[i]].f-=t; e[ops(pre[i])].f+=t; } for(int i=1;i&lt;=n;i++){ if(dis[i]&lt;inf){ tmp[i]+=dis[i]; } } } return ;}int main(){ init(); scanf(\"%d%d%d%d\",&amp;n,&amp;m,&amp;s,&amp;t); for(int i=1;i&lt;=m;i++){ int x,y,f,w; scanf(\"%d%d%d%d\",&amp;x,&amp;y,&amp;f,&amp;w); make(x,y,f,w); } spfa(s,t); int flow=0; int cost=0; EK(s,t,flow,cost); printf(\"%d %d\\n\",flow,cost); return 0;} debug_ 123456789101112void debug_build(){ printf(\"\\n\"); printf(\"%d\\n\",tot); for(int i=0;i&lt;tot;i+=2){ int x=e[ops(i)].y; int y=e[i].y; int w=e[i].w; printf(\"%d -&gt; %d : %d\\n\",x,y,w); } printf(\"\\n\"); return ;}","categories":[{"name":"-模板","slug":"模板","permalink":"http://stairsupon.github.io/categories/%E6%A8%A1%E6%9D%BF/"}],"tags":[]}],"categories":[{"name":"-模板","slug":"模板","permalink":"http://stairsupon.github.io/categories/%E6%A8%A1%E6%9D%BF/"},{"name":"闲话","slug":"闲话","permalink":"http://stairsupon.github.io/categories/%E9%97%B2%E8%AF%9D/"},{"name":"题解","slug":"题解","permalink":"http://stairsupon.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"网络流","slug":"网络流","permalink":"http://stairsupon.github.io/categories/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"-二分","slug":"二分","permalink":"http://stairsupon.github.io/categories/%E4%BA%8C%E5%88%86/"}],"tags":[{"name":"鲜花","slug":"鲜花","permalink":"http://stairsupon.github.io/tags/%E9%B2%9C%E8%8A%B1/"},{"name":"感言","slug":"感言","permalink":"http://stairsupon.github.io/tags/%E6%84%9F%E8%A8%80/"},{"name":"题解","slug":"题解","permalink":"http://stairsupon.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"凸轮","slug":"凸轮","permalink":"http://stairsupon.github.io/tags/%E5%87%B8%E8%BD%AE/"},{"name":"网络流","slug":"网络流","permalink":"http://stairsupon.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"图论建模","slug":"图论建模","permalink":"http://stairsupon.github.io/tags/%E5%9B%BE%E8%AE%BA%E5%BB%BA%E6%A8%A1/"},{"name":"二分","slug":"二分","permalink":"http://stairsupon.github.io/tags/%E4%BA%8C%E5%88%86/"},{"name":"贪心","slug":"贪心","permalink":"http://stairsupon.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"构造","slug":"构造","permalink":"http://stairsupon.github.io/tags/%E6%9E%84%E9%80%A0/"}]}